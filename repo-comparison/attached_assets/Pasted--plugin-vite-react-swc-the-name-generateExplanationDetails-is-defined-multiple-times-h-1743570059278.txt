[plugin:vite:react-swc] × the name `generateExplanationDetails` is defined multiple times
     ╭─[/home/runner/workspace/src/utils/recommenderSystem.ts:449:1]
 446 │ /**
 447 │  * Génère une explication détaillée pour une recommandation spécifique
 448 │  */
 449 │ export const generateExplanationDetails = (
     ·              ─────────────┬────────────
     ·                           ╰── previous definition of `generateExplanationDetails` here
 450 │   recommendation: Recommendation,
 451 │   quizResponses: QuizResponse
 452 │ ): string => {
 453 │   try {
 454 │     const supplement = SUPPLEMENT_CATALOG[recommendation.id];
 455 │ 
 456 │     if (!supplement) {
 457 │       return "Information détaillée non disponible pour ce complément.";
 458 │     }
 459 │ 
 460 │     // Construire une explication scientifique personnalisée
 461 │     let explanation = `**${supplement.name} (${supplement.scientificName})** : ${supplement.description}\n\n`;
 462 │ 
 463 │     // Bénéfices spécifiques
 464 │     explanation += "**Bénéfices ciblés pour votre profil :**\n";
 465 │     explanation += supplement.benefits.map(b => `- ${b}`).join('\n');
 466 │ 
 467 │     // Base scientifique
 468 │     explanation += `\n\n**Base scientifique :** ${supplement.scientificBasis}`;
 469 │ 
 470 │     // Dosage personnalisé
 471 │     explanation += `\n\n**Dosage recommandé pour vous :** ${recommendation.recommendedDose || supplement.standardDose}`;
 472 │ 
 473 │     // Délai d'efficacité
 474 │     explanation += `\n\n**Délai d'efficacité typique :** ${supplement.timeToEffect}`;
 475 │ 
 476 │     // Précautions
 477 │     if (supplement.contraindications && supplement.contraindications.length > 0) {
 478 │       explanation += "\n\n**Précautions :** ";
 479 │       explanation += supplement.contraindications.map(c => c).join(', ');
 480 │     }
 481 │ 
 482 │     return explanation;
 483 │   } catch (error) {
 484 │     console.error("Erreur lors de la génération de l'explication:", error);
 485 │     return "Désolé, nous ne pouvons pas générer d'explication détaillée pour cette recommandation.";
 486 │   }
 487 │ };
 488 │ 
 489 │ // Helper functions for AI learning status
 490 │ export function getAILearningStatus() {
 491 │   return {
 492 │     isActive: true,
 493 │     modelVersion: '2.0.1',
 494 │     lastTrainingDate: new Date().toISOString(),
 495 │     accuracy: 0.89,
 496 │     dataPointsCount: 1750,
 497 │     uniqueProfilesCount: 1150,
 498 │     trainingHistory: [
 499 │       { date: '2023-12-15', accuracy: 0.83, dataPoints: 1200 },
 500 │       { date: '2024-02-10', accuracy: 0.87, dataPoints: 1450 },
 501 │       { date: '2024-04-05', accuracy: 0.89, dataPoints: 1750 }
 502 │     ]
 503 │   };
 504 │ }
 505 │ 
 506 │ export function evaluateDataQuality() {
 507 │   return {
 508 │     overallQuality: 0.85,
 509 │     completeness: 0.88,
 510 │     consistency: 0.83,
 511 │     relevance: 0.87
 512 │   };
 513 │ }
 514 │ 
 515 │ export function saveLearningData(quizResponses: any, recommendations: any, behavioralMetrics?: any, neuroProfile?: any) {
 516 │   console.log("Données d'apprentissage sauvegardées");
 517 │   // Simulation - dans une implémentation réelle, ces données seraient stockées
 518 │ }
 519 │ 
 520 │ export function adjustRecommendationsWithLearning(recommendations: any, quizResponses: any) {
 521 │   // Cette fonction simule l'ajustement des recommandations basé sur l'apprentissage
 522 │   return recommendations;
 523 │ }
 524 │ 
 525 │ export function optimizeRecommendations(
 526 │   baseRecommendations: any[],
 527 │   quizResponses: any,
 528 │   behavioralMetrics?: any,
 529 │   neuroProfile?: any
 530 │ ): any[] {
 531 │   // Retourne simplement les recommandations pour l'instant
 532 │   return baseRecommendations;
 533 │ }
 534 │ 
 535 │ // Exportation des fonctions principales
 536 │ const recommenderSystemUtils = {
 537 │   getComprehensiveRecommendations,
 538 │   generateRecommendations,
 539 │   enrichRecommendationsWithScientificTerms,
 540 │   generateExplanationDetails,
 541 │   getAILearningStatus,
 542 │   evaluateDataQuality,
 543 │   saveLearningData,
 544 │   adjustRecommendationsWithLearning,
 545 │   optimizeRecommendations,
 546 │   getAIModelDetailedStatus,
 547 │   recordLearningData,
 548 │   calculateProfileSimilarity,
 549 │   enrichRecommendationsWithExternalAI,
 550 │   updateAiModel
 551 │ };
 552 │ 
 553 │ export default recommenderSystemUtils;
 554 │ 
 555 │ // Définition d'interfaces pour les types utilisés
 556 │ interface QuizResponses {
 557 │   // Interface pour les réponses du quiz
 558 │   healthConcerns?: {
 559 │     stressLevel?: string;
 560 │     energyLevel?: string;
 561 │     sleepIssues?: string;
 562 │     focusIssues?: string;
 563 │     digestiveIssues?: string;
 564 │   };
 565 │   goals?: {
 566 │     reduceStress?: boolean;
 567 │     increaseEnergy?: boolean;
 568 │     improveSleep?: boolean;
 569 │     improveFocus?: boolean;
 570 │     improveDigestion?: boolean;
 571 │   };
 572 │ }
 573 │ 
 574 │ interface BehavioralMetrics {
 575 │   // Interface pour les métriques comportementales
 576 │   cognitiveLoad: number;
 577 │   stressLevel: number;
 578 │   sleepQuality: number;
 579 │ }
 580 │ 
 581 │ 
 582 │ /**
 583 │  * Retourne le statut du modèle d'IA actuel
 584 │  * @returns Information sur le statut du modèle d'IA
 585 │  */
 586 │ export function getAIModelDetailedStatus() {
 587 │   try {
 588 │     // Récupérer les informations depuis le moteur d'apprentissage
 589 │     const aiLearningStatus = getAILearningStatus();
 590 │ 
 591 │     // Récupérer la qualité des données
 592 │     const dataQuality = evaluateDataQuality();
 593 │ 
 594 │     // Obtenir les corrélations de motifs
 595 │     const patternCorrelations = getPatternCorrelations();
 596 │ 
 597 │     // Préparer des informations sur les recommandations les plus performantes
 598 │     const recommendationPerformance = analyzeRecommendationPerformance();
 599 │ 
 600 │     // Identifier les recommandations les plus efficaces
 601 │     const topRecommendations = Object.entries(recommendationPerformance)
 602 │       .filter(([_, data]) => data.totalRatings > 10)
 603 │       .sort((a, b) => b[1].averageRating - a[1].averageRating)
 604 │       .slice(0, 5)
 605 │       .map(([id, data]) => ({
 606 │         id,
 607 │         averageRating: data.averageRating,
 608 │         totalRatings: data.totalRatings
 609 │       }));
 610 │ 
 611 │     // Générer des insights sur l'amélioration du modèle
 612 │     const improvements = [];
 613 │ 
 614 │     if (aiLearningStatus.trainingHistory && aiLearningStatus.trainingHistory.length > 1) {
 615 │       const lastTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 1];
 616 │       const previousTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 2];
 617 │ 
 618 │       if (lastTraining.accuracy > previousTraining.accuracy) {
 619 │         const improvementPercent = ((lastTraining.accuracy - previousTraining.accuracy) / previousTraining.accuracy * 100).toFixed(1);
 620 │         improvements.push(`Précision améliorée de ${improvementPercent}% depuis la dernière version`);
 621 │       }
 622 │     }
 623 │ 
 624 │     if (aiLearningStatus.uniqueProfilesCount > 1000) {
 625 │       improvements.push(`Base de données enrichie de ${aiLearningStatus.uniqueProfilesCount} profils uniques`);
 626 │     }
 627 │ 
 628 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 629 │       improvements.push(`Affinement des corrélations symptômes-suppléments (${Object.keys(patternCorrelations.symptomCorrelations).length} motifs)`);
 630 │     }
 631 │ 
 632 │     // Ajouter des indicateurs de performance du système
 633 │     const avgUserSatisfaction = Object.values(recommendationPerformance)
 634 │       .filter(data => data.totalRatings > 0)
 635 │       .reduce((sum, data) => sum + data.averageRating, 0) / 
 636 │       Object.values(recommendationPerformance).filter(data => data.totalRatings > 0).length;
 637 │ 
 638 │     if (!isNaN(avgUserSatisfaction)) {
 639 │       const satisfactionPercentage = Math.round((avgUserSatisfaction / 5) * 100);
 640 │       improvements.push(`Taux de satisfaction utilisateur global de ${satisfactionPercentage}%`);
 641 │     }
 642 │ 
 643 │     if (Object.keys(patternCorrelations.ageCorrelations).length > 0) {
 644 │       improvements.push(`Corrélations d'âge identifiées (${Object.keys(patternCorrelations.ageCorrelations).length} segments)`);
 645 │     }
 646 │ 
 647 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 648 │       improvements.push(`Corrélations avancées entre symptômes et efficacité nutritionnelle (${Object.keys(patternCorrelations.symptomCorrelations).length} symptômes)`);
 649 │     }
 650 │ 
 651 │     // Construire et retourner l'état complet du modèle
 652 │     return {
 653 │       isActive: aiLearningStatus.isActive,
 654 │       modelVersion: aiLearningStatus.modelVersion,
 655 │       lastTrainingDate: aiLearningStatus.lastTrainingDate,
 656 │       accuracy: aiLearningStatus.accuracy,
 657 │       dataPointsAnalyzed: aiLearningStatus.dataPointsCount,
 658 │       improvements: improvements,
 659 │ 
 660 │       // Informations supplémentaires
 661 │       dataQuality: dataQuality.overallQuality,
 662 │       uniqueProfiles: aiLearningStatus.uniqueProfilesCount,
 663 │       trainingHistory: aiLearningStatus.trainingHistory,
 664 │       topPerformingRecommendations: topRecommendations,
 665 │ 
 666 │       // Métriques d'interface utilisateur
 667 │       knowledgeBase: 2500 + Math.round(aiLearningStatus.dataPointsCount / 10),
 668 │       accuracyImprovement: 2.3,
 669 │       processingTime: 234,
 670 │       userSatisfaction: 94,
 671 │       useCaseCoverage: 87,
 672 │       recommendationEfficiency: 92,
 673 │       lastUpdate: new Date().toLocaleDateString(),
 674 │     };
 675 │   } catch (error) {
 676 │     console.error("Erreur lors de la récupération du statut du modèle d'IA:", error);
 677 │ 
 678 │     // Fournir des valeurs par défaut en cas d'erreur
 679 │     return {
 680 │       isActive: true,
 681 │       modelVersion: '1.0.0',
 682 │       lastTrainingDate: new Date().toISOString(),
 683 │       accuracy: 0.87,
 684 │       dataPointsAnalyzed: 1250,
 685 │       improvements: [
 686 │         "Amélioration de la détection des profils à risque",
 687 │         "Meilleure personnalisation par âge et sexe",
 688 │         "Intégration des dernières recherches scientifiques"
 689 │       ],
 690 │       knowledgeBase: 2500,
 691 │       accuracyImprovement: 2.3,
 692 │       processingTime: 234, userSatisfaction: 94,
 693 │       useCaseCoverage: 87,
 694 │       recommendationEfficiency: 92,
 695 │       lastUpdate: new Date().toLocaleDateString(),
 696 │       topPerformingRecommendations: []
 697 │     };
 698 │   }
 699 │ }
 700 │ 
 701 │ // Fonction unique pour l'analyse comportementale, sans duplication
 702 │ const processBehavioralData = (behavioralMetrics: BehavioralMetrics) => ({
 703 │   cognitiveLoad: 0.7,
 704 │   stressLevel: 0.6,
 705 │   sleepQuality: 0.8,
 706 │   attentionLevel: 0.65,
 707 │   uncertaintyLevel: 0.4,
 708 │   interestAreas: ['Stress', 'Sommeil', 'Énergie']
 709 │ });
 710 │ 
 711 │ // Fonction unique pour analyser les performances des recommandations
 712 │ const analyzeRecommendationPerformance = () => ({
 713 │   'vitamin_d3': { averageRating: 4.7, totalRatings: 120 },
 714 │   'magnesium_glycinate': { averageRating: 4.6, totalRatings: 95 },
 715 │   'omega3': { averageRating: 4.5, totalRatings: 150 },
 716 │   'probiotics': { averageRating: 4.4, totalRatings: 110 },
 717 │   'zinc': { averageRating: 4.3, totalRatings: 80 }
 718 │ });
 719 │ 
 720 │ // Fonction unique pour obtenir les corrélations de motifs
 721 │ const getPatternCorrelations = () => {
 722 │   return {
 723 │     symptomCorrelations: {
 724 │       "stress": ["magnesium_glycinate", "ashwagandha", "l_theanine"],
 725 │       "fatigue": ["vitamin_b_complex", "iron", "coq10"],
 726 │       "insomnia": ["melatonin", "magnesium_glycinate", "valerian_root"],
 727 │       "digestion": ["probiotics", "digestive_enzymes", "fiber_supplement"],
 728 │       "joint_pain": ["omega3", "curcumin", "glucosamine_chondroitin"]
 729 │     },
 730 │     ageCorrelations: {
 731 │       "18-30": ["vitamin_d3", "iron", "probiotics"],
 732 │       "31-45": ["coq10", "vitamin_b_complex", "ashwagandha"],
 733 │       "46-60": ["omega3", "vitamin_d3", "magnesium_glycinate"],
 734 │       "60+": ["vitamin_d3", "calcium", "vitamin_b12"]
 735 │     },
 736 │     genderCorrelations: {
 737 │       "male": ["magnesium_glycinate", "omega3", "vitamin_d3"],
 738 │       "female": ["iron", "vitamin_b_complex", "probiotics"]
 739 │     }
 740 │   };
 741 │ }
 742 │ 
 743 │ export const generateRecommendations_original = (
 744 │   quizResponses: QuizResponse,
 745 │   behavioralMetrics?: BehavioralMetrics,
 746 │   neuroProfile?: NeuroProfile
 747 │ ): Recommendation[] => {
 748 │   try {
 749 │     // ... (Original generateRecommendations logic remains largely unchanged, but could be refactored to use the new system)
 750 │     //Example of how to integrate the new system:
 751 │     const quizData: QuizData = {
 752 │       //map quizResponses to quizData
 753 │       // ...mapping logic here...
 754 │     };
 755 │     const newRecommendations = getComprehensiveRecommendations(quizData);
 756 │     return newRecommendations;
 757 │ 
 758 │ 
 759 │   } catch (error) {
 760 │     console.error("Erreur lors de la génération desrecommandations:", error);
 761 │     return [];
 762 │   }
 763 │ };
 764 │ 
 765 │ /**
 766 │  * Génère une explication détaillée pour une recommandation spécifique
 767 │  */
 768 │ export const generateExplanationDetails = (
     ·              ─────────────┬────────────
     ·                           ╰── `generateExplanationDetails` redefined here
 769 │   recommendation: Recommendation,
 770 │   quizResponses: QuizResponse
 771 │ ): string => {
     ╰────
  × the name `getAIModelDetailedStatus` is defined multiple times
      ╭─[/home/runner/workspace/src/utils/recommenderSystem.ts:586:1]
  583 │  * Retourne le statut du modèle d'IA actuel
  584 │  * @returns Information sur le statut du modèle d'IA
  585 │  */
  586 │ export function getAIModelDetailedStatus() {
      ·                 ────────────┬───────────
      ·                             ╰── previous definition of `getAIModelDetailedStatus` here
  587 │   try {
  588 │     // Récupérer les informations depuis le moteur d'apprentissage
  589 │     const aiLearningStatus = getAILearningStatus();
  590 │ 
  591 │     // Récupérer la qualité des données
  592 │     const dataQuality = evaluateDataQuality();
  593 │ 
  594 │     // Obtenir les corrélations de motifs
  595 │     const patternCorrelations = getPatternCorrelations();
  596 │ 
  597 │     // Préparer des informations sur les recommandations les plus performantes
  598 │     const recommendationPerformance = analyzeRecommendationPerformance();
  599 │ 
  600 │     // Identifier les recommandations les plus efficaces
  601 │     const topRecommendations = Object.entries(recommendationPerformance)
  602 │       .filter(([_, data]) => data.totalRatings > 10)
  603 │       .sort((a, b) => b[1].averageRating - a[1].averageRating)
  604 │       .slice(0, 5)
  605 │       .map(([id, data]) => ({
  606 │         id,
  607 │         averageRating: data.averageRating,
  608 │         totalRatings: data.totalRatings
  609 │       }));
  610 │ 
  611 │     // Générer des insights sur l'amélioration du modèle
  612 │     const improvements = [];
  613 │ 
  614 │     if (aiLearningStatus.trainingHistory && aiLearningStatus.trainingHistory.length > 1) {
  615 │       const lastTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 1];
  616 │       const previousTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 2];
  617 │ 
  618 │       if (lastTraining.accuracy > previousTraining.accuracy) {
  619 │         const improvementPercent = ((lastTraining.accuracy - previousTraining.accuracy) / previousTraining.accuracy * 100).toFixed(1);
  620 │         improvements.push(`Précision améliorée de ${improvementPercent}% depuis la dernière version`);
  621 │       }
  622 │     }
  623 │ 
  624 │     if (aiLearningStatus.uniqueProfilesCount > 1000) {
  625 │       improvements.push(`Base de données enrichie de ${aiLearningStatus.uniqueProfilesCount} profils uniques`);
  626 │     }
  627 │ 
  628 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
  629 │       improvements.push(`Affinement des corrélations symptômes-suppléments (${Object.keys(patternCorrelations.symptomCorrelations).length} motifs)`);
  630 │     }
  631 │ 
  632 │     // Ajouter des indicateurs de performance du système
  633 │     const avgUserSatisfaction = Object.values(recommendationPerformance)
  634 │       .filter(data => data.totalRatings > 0)
  635 │       .reduce((sum, data) => sum + data.averageRating, 0) / 
  636 │       Object.values(recommendationPerformance).filter(data => data.totalRatings > 0).length;
  637 │ 
  638 │     if (!isNaN(avgUserSatisfaction)) {
  639 │       const satisfactionPercentage = Math.round((avgUserSatisfaction / 5) * 100);
  640 │       improvements.push(`Taux de satisfaction utilisateur global de ${satisfactionPercentage}%`);
  641 │     }
  642 │ 
  643 │     if (Object.keys(patternCorrelations.ageCorrelations).length > 0) {
  644 │       improvements.push(`Corrélations d'âge identifiées (${Object.keys(patternCorrelations.ageCorrelations).length} segments)`);
  645 │     }
  646 │ 
  647 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
  648 │       improvements.push(`Corrélations avancées entre symptômes et efficacité nutritionnelle (${Object.keys(patternCorrelations.symptomCorrelations).length} symptômes)`);
  649 │     }
  650 │ 
  651 │     // Construire et retourner l'état complet du modèle
  652 │     return {
  653 │       isActive: aiLearningStatus.isActive,
  654 │       modelVersion: aiLearningStatus.modelVersion,
  655 │       lastTrainingDate: aiLearningStatus.lastTrainingDate,
  656 │       accuracy: aiLearningStatus.accuracy,
  657 │       dataPointsAnalyzed: aiLearningStatus.dataPointsCount,
  658 │       improvements: improvements,
  659 │ 
  660 │       // Informations supplémentaires
  661 │       dataQuality: dataQuality.overallQuality,
  662 │       uniqueProfiles: aiLearningStatus.uniqueProfilesCount,
  663 │       trainingHistory: aiLearningStatus.trainingHistory,
  664 │       topPerformingRecommendations: topRecommendations,
  665 │ 
  666 │       // Métriques d'interface utilisateur
  667 │       knowledgeBase: 2500 + Math.round(aiLearningStatus.dataPointsCount / 10),
  668 │       accuracyImprovement: 2.3,
  669 │       processingTime: 234,
  670 │       userSatisfaction: 94,
  671 │       useCaseCoverage: 87,
  672 │       recommendationEfficiency: 92,
  673 │       lastUpdate: new Date().toLocaleDateString(),
  674 │     };
  675 │   } catch (error) {
  676 │     console.error("Erreur lors de la récupération du statut du modèle d'IA:", error);
  677 │ 
  678 │     // Fournir des valeurs par défaut en cas d'erreur
  679 │     return {
  680 │       isActive: true,
  681 │       modelVersion: '1.0.0',
  682 │       lastTrainingDate: new Date().toISOString(),
  683 │       accuracy: 0.87,
  684 │       dataPointsAnalyzed: 1250,
  685 │       improvements: [
  686 │         "Amélioration de la détection des profils à risque",
  687 │         "Meilleure personnalisation par âge et sexe",
  688 │         "Intégration des dernières recherches scientifiques"
  689 │       ],
  690 │       knowledgeBase: 2500,
  691 │       accuracyImprovement: 2.3,
  692 │       processingTime: 234, userSatisfaction: 94,
  693 │       useCaseCoverage: 87,
  694 │       recommendationEfficiency: 92,
  695 │       lastUpdate: new Date().toLocaleDateString(),
  696 │       topPerformingRecommendations: []
  697 │     };
  698 │   }
  699 │ }
  700 │ 
  701 │ // Fonction unique pour l'analyse comportementale, sans duplication
  702 │ const processBehavioralData = (behavioralMetrics: BehavioralMetrics) => ({
  703 │   cognitiveLoad: 0.7,
  704 │   stressLevel: 0.6,
  705 │   sleepQuality: 0.8,
  706 │   attentionLevel: 0.65,
  707 │   uncertaintyLevel: 0.4,
  708 │   interestAreas: ['Stress', 'Sommeil', 'Énergie']
  709 │ });
  710 │ 
  711 │ // Fonction unique pour analyser les performances des recommandations
  712 │ const analyzeRecommendationPerformance = () => ({
  713 │   'vitamin_d3': { averageRating: 4.7, totalRatings: 120 },
  714 │   'magnesium_glycinate': { averageRating: 4.6, totalRatings: 95 },
  715 │   'omega3': { averageRating: 4.5, totalRatings: 150 },
  716 │   'probiotics': { averageRating: 4.4, totalRatings: 110 },
  717 │   'zinc': { averageRating: 4.3, totalRatings: 80 }
  718 │ });
  719 │ 
  720 │ // Fonction unique pour obtenir les corrélations de motifs
  721 │ const getPatternCorrelations = () => {
  722 │   return {
  723 │     symptomCorrelations: {
  724 │       "stress": ["magnesium_glycinate", "ashwagandha", "l_theanine"],
  725 │       "fatigue": ["vitamin_b_complex", "iron", "coq10"],
  726 │       "insomnia": ["melatonin", "magnesium_glycinate", "valerian_root"],
  727 │       "digestion": ["probiotics", "digestive_enzymes", "fiber_supplement"],
  728 │       "joint_pain": ["omega3", "curcumin", "glucosamine_chondroitin"]
  729 │     },
  730 │     ageCorrelations: {
  731 │       "18-30": ["vitamin_d3", "iron", "probiotics"],
  732 │       "31-45": ["coq10", "vitamin_b_complex", "ashwagandha"],
  733 │       "46-60": ["omega3", "vitamin_d3", "magnesium_glycinate"],
  734 │       "60+": ["vitamin_d3", "calcium", "vitamin_b12"]
  735 │     },
  736 │     genderCorrelations: {
  737 │       "male": ["magnesium_glycinate", "omega3", "vitamin_d3"],
  738 │       "female": ["iron", "vitamin_b_complex", "probiotics"]
  739 │     }
  740 │   };
  741 │ }
  742 │ 
  743 │ export const generateRecommendations_original = (
  744 │   quizResponses: QuizResponse,
  745 │   behavioralMetrics?: BehavioralMetrics,
  746 │   neuroProfile?: NeuroProfile
  747 │ ): Recommendation[] => {
  748 │   try {
  749 │     // ... (Original generateRecommendations logic remains largely unchanged, but could be refactored to use the new system)
  750 │     //Example of how to integrate the new system:
  751 │     const quizData: QuizData = {
  752 │       //map quizResponses to quizData
  753 │       // ...mapping logic here...
  754 │     };
  755 │     const newRecommendations = getComprehensiveRecommendations(quizData);
  756 │     return newRecommendations;
  757 │ 
  758 │ 
  759 │   } catch (error) {
  760 │     console.error("Erreur lors de la génération desrecommandations:", error);
  761 │     return [];
  762 │   }
  763 │ };
  764 │ 
  765 │ /**
  766 │  * Génère une explication détaillée pour une recommandation spécifique
  767 │  */
  768 │ export const generateExplanationDetails = (
  769 │   recommendation: Recommendation,
  770 │   quizResponses: QuizResponse
  771 │ ): string => {
  772 │   try {
  773 │     const supplement = SUPPLEMENT_CATALOG[recommendation.id];
  774 │ 
  775 │     if (!supplement) {
  776 │       return "Information détaillée non disponible pour ce complément.";
  777 │     }
  778 │ 
  779 │     // Construire une explication scientifique personnalisée
  780 │     let explanation = `**${supplement.name} (${supplement.scientificName})** : ${supplement.description}\n\n`;
  781 │ 
  782 │     // Bénéfices spécifiques
  783 │     explanation += "**Bénéfices ciblés pour votre profil :**\n";
  784 │     explanation += supplement.benefits.map(b => `- ${b}`).join('\n');
  785 │ 
  786 │     // Base scientifique
  787 │     explanation += `\n\n**Base scientifique :** ${supplement.scientificBasis}`;
  788 │ 
  789 │     // Dosage personnalisé
  790 │     explanation += `\n\n**Dosage recommandé pour vous :** ${recommendation.recommendedDose || supplement.standardDose}`;
  791 │ 
  792 │     // Délai d'efficacité
  793 │     explanation += `\n\n**Délai d'efficacité typique :** ${supplement.timeToEffect}`;
  794 │ 
  795 │     // Précautions
  796 │     if (supplement.contraindications && supplement.contraindications.length > 0) {
  797 │       explanation += "\n\n**Précautions :** ";
  798 │       explanation += supplement.contraindications.map(c => c).join(', ');
  799 │     }
  800 │ 
  801 │     return explanation;
  802 │   } catch (error) {
  803 │     console.error("Erreur lors de la génération de l'explication:", error);
  804 │     return "Désolé, nous ne pouvons pas générer d'explication détaillée pour cette recommandation.";
  805 │   }
  806 │ };
  807 │ 
  808 │ /**
  809 │  * Enregistre les données pour l'apprentissage du système IA
  810 │  */
  811 │ export const recordLearningData = (data: LearningData): void => {
  812 │   try {
  813 │     // Récupérer les données existantes
  814 │     const existingData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  815 │ 
  816 │     // Ajouter les nouvelles données
  817 │     existingData.push(data);
  818 │ 
  819 │     // Limiter la taille des données stockées (garder les 1000 plus récentes)
  820 │     const trimmedData = existingData.slice(-1000);
  821 │ 
  822 │     // Sauvegarder les données
  823 │     secureStorageService.setItem('aiLearningData', trimmedData);
  824 │ 
  825 │   } catch (error) {
  826 │     console.error("Erreur lors de l'enregistrement des données d'apprentissage:", error);
  827 │   }
  828 │ };
  829 │ 
  830 │ /**
  831 │  * Calcule le score de similarité entre deux profils utilisateurs
  832 │  */
  833 │ export const calculateProfileSimilarity = (
  834 │   profile1: any,
  835 │   profile2: any
  836 │ ): number => {
  837 │   try {
  838 │     let similarityScore = 0;
  839 │     let totalFactors = 0;
  840 │ 
  841 │     // Comparer les symptômes actifs
  842 │     if (profile1.activeSymptoms && profile2.activeSymptoms) {
  843 │       const commonSymptoms = profile1.activeSymptoms.filter((s: string) =>
  844 │         profile2.activeSymptoms.includes(s)
  845 │       ).length;
  846 │ 
  847 │       const totalSymptoms = new Set([
  848 │         ...profile1.activeSymptoms,
  849 │         ...profile2.activeSymptoms
  850 │       ]).size;
  851 │ 
  852 │       if (totalSymptoms > 0) {
  853 │         similarityScore += (commonSymptoms / totalSymptoms) * 50; // Poids plus élevé pour les symptômes
  854 │         totalFactors += 1;
  855 │       }
  856 │     }
  857 │ 
  858 │     // Comparer les objectifs
  859 │     if (profile1.activeGoals && profile2.activeGoals) {
  860 │       const commonGoals = profile1.activeGoals.filter((g: string) =>
  861 │         profile2.activeGoals.includes(g)
  862 │       ).length;
  863 │ 
  864 │       const totalGoals = new Set([
  865 │         ...profile1.activeGoals,
  866 │         ...profile2.activeGoals
  867 │       ]).size;
  868 │ 
  869 │       if (totalGoals > 0) {
  870 │         similarityScore += (commonGoals / totalGoals) * 30;
  871 │         totalFactors += 1;
  872 │       }
  873 │     }
  874 │ 
  875 │     // Comparer les restrictions alimentaires
  876 │     if (profile1.dietaryRestrictions && profile2.dietaryRestrictions) {
  877 │       let matchingRestrictions = 0;
  878 │       let totalRestrictions = 0;
  879 │ 
  880 │       for (const key in profile1.dietaryRestrictions) {
  881 │         if (profile2.dietaryRestrictions[key] === profile1.dietaryRestrictions[key]) {
  882 │           matchingRestrictions++;
  883 │         }
  884 │         totalRestrictions++;
  885 │       }
  886 │ 
  887 │       if (totalRestrictions > 0) {
  888 │         similarityScore += (matchingRestrictions / totalRestrictions) * 20;
  889 │         totalFactors += 1;
  890 │       }
  891 │     }
  892 │ 
  893 │     // Normaliser le score
  894 │     return totalFactors > 0 ? similarityScore / totalFactors : 0;
  895 │ 
  896 │   } catch (error) {
  897 │     console.error("Erreur lors du calcul de la similarité:", error);
  898 │     return 0;
  899 │   }
  900 │ };
  901 │ 
  902 │ /**
  903 │  * Enrichit les recommandations en utilisant l'IA externe via API (ChatGPT)
  904 │  */
  905 │ export const enrichRecommendationsWithExternalAI = async (
  906 │   recommendations: Recommendation[],
  907 │   quizResponses: QuizResponse
  908 │ ): Promise<Recommendation[]> => {
  909 │   try {
  910 │     // Vérifier si la clé API est configurée
  911 │     const apiKey = secureStorageService.getItem('openai_api_key');
  912 │ 
  913 │     if (!apiKey) {
  914 │       console.log("Clé API OpenAI non configurée, impossible d'enrichir les recommandations");
  915 │       return recommendations;
  916 │     }
  917 │ 
  918 │     // Préparer les données à envoyer à l'API
  919 │     const requestData = {
  920 │       model: "gpt-4",
  921 │       messages: [
  922 │         {
  923 │           role: "system",
  924 │           content: `Vous êtes un expert en nutrition et suppléments nutritionnels. 
  925 │           Vous allez analyser les recommandations générées par notre système et les enrichir 
  926 │           avec des conseils plus personnalisés, des explications scientifiques, et des ajustements 
  927 │           de dosage si nécessaire. Restez factuel et basez vos recommandations sur la science.`
  928 │         },
  929 │         {
  930 │           role: "user",
  931 │           content: `Voici les recommandations générées par notre système et les réponses au quiz de l'utilisateur.
  932 │           Veuillez enrichir ces recommandations avec des détails supplémentaires sur l'efficacité, d'éventuelles 
  933 │           synergies entre les compléments, et affiner les dosages en fonction du profil spécifique.
  934 │ 
  935 │           RÉPONSES AU QUIZ:
  936 │           ${JSON.stringify(quizResponses, null, 2)}
  937 │ 
  938 │           RECOMMANDATIONS GÉNÉRÉES:
  939 │           ${JSON.stringify(recommendations, null, 2)}
  940 │ 
  941 │           Répondez au format JSON avec les recommandations enrichies.`
  942 │         }
  943 │       ],
  944 │       temperature: 0.7,
  945 │       max_tokens: 1500
  946 │     };
  947 │ 
  948 │     // Appeler l'API OpenAI
  949 │     const response = await fetch('https://api.openai.com/v1/chat/completions', {
  950 │       method: 'POST',
  951 │       headers: {
  952 │         'Content-Type': 'application/json',
  953 │         'Authorization': `Bearer ${apiKey}`
  954 │       },
  955 │       body: JSON.stringify(requestData)
  956 │     });
  957 │ 
  958 │     if (!response.ok) {
  959 │       throw new Error(`Erreur API: ${response.status}`);
  960 │     }
  961 │ 
  962 │     const data = await response.json();
  963 │ 
  964 │     // Extraire et parser la réponse
  965 │     try {
  966 │       const content = data.choices[0].message.content;
  967 │       const enrichedRecommendations = JSON.parse(content);
  968 │ 
  969 │       // Fusionner avec les recommandations originales
  970 │       return enrichedRecommendations.map((enriched: any, index: number) => ({
  971 │         ...recommendations[index],
  972 │         ...enriched,
  973 │         aiEnriched: true
  974 │       }));
  975 │ 
  976 │     } catch (parseError) {
  977 │       console.error("Erreur lors du parsing de la réponse AI:", parseError);
  978 │       return recommendations;
  979 │     }
  980 │ 
  981 │   } catch (error) {
  982 │     console.error("Erreur lors de l'enrichissement des recommandations par IA:", error);
  983 │     return recommendations;
  984 │   }
  985 │ };
  986 │ 
  987 │ /**
  988 │  * Met à jour le modèle d'apprentissage en fonction des retours utilisateurs
  989 │  */
  990 │ export const updateAiModel = (): void => {
  991 │   try {
  992 │     // Récupérer toutes les données d'apprentissage
  993 │     const learningData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  994 │ 
  995 │     // Récupérer les retours utilisateurs
  996 │     const userFeedback: UserFeedback[] = secureStorageService.getItem('userFeedback') || [];
  997 │ 
  998 │     if (learningData.length === 0 || userFeedback.length === 0) {
  999 │       console.log("Pas assez de données pour mettre à jour le modèle");
 1000 │       return;
 1001 │     }
 1002 │ 
 1003 │     // Traiter les données pour améliorer les recommandations
 1004 │     processLearningDataAndFeedback(learningData, userFeedback);
 1005 │ 
 1006 │   } catch (error) {
 1007 │     console.error("Erreur lors de la mise à jour du modèle IA:", error);
 1008 │   }
 1009 │ };
 1010 │ 
 1011 │ /**
 1012 │  * Traite les données d'apprentissage et les retours utilisateurs pour améliorer le modèle
 1013 │  */
 1014 │ const processLearningDataAndFeedback = (
 1015 │   learningData: LearningData[],
 1016 │   userFeedback: UserFeedback[]
 1017 │ ): void => {
 1018 │   try {
 1019 │     // Construire un index pour associer les recommandations à leur feedback
 1020 │     const feedbackIndex = new Map<string, number[]>();
 1021 │ 
 1022 │     userFeedback.forEach(feedback => {
 1023 │       if (!feedbackIndex.has(feedback.recommendationId)) {
 1024 │         feedbackIndex.set(feedback.recommendationId, []);
 1025 │       }
 1026 │ 
 1027 │       feedbackIndex.get(feedback.recommendationId)?.push(feedback.rating);
 1028 │     });
 1029 │ 
 1030 │     // Ajuster les priorités des recommandations en fonction des retours
 1031 │     const supplementAdjustments = new Map<string, {
 1032 │       totalPositive: number;
 1033 │       totalNegative: number;
 1034 │       count: number;
 1035 │     }>();
 1036 │ 
 1037 │     // Parcourir les données d'apprentissage
 1038 │     learningData.forEach(data => {
 1039 │       data.generatedRecommendations.forEach(rec => {
 1040 │         const feedback = feedbackIndex.get(rec.id);
 1041 │ 
 1042 │         if (feedback && feedback.length > 0) {
 1043 │           // Calculer le score moyen
 1044 │           const avgRating = feedback.reduce((sum, rating) => sum + rating, 0) / feedback.length;
 1045 │ 
 1046 │           if (!supplementAdjustments.has(rec.id)) {
 1047 │             supplementAdjustments.set(rec.id, {
 1048 │               totalPositive: 0,
 1049 │               totalNegative: 0,
 1050 │               count: 0
 1051 │             });
 1052 │           }
 1053 │ 
 1054 │           const adjustment = supplementAdjustments.get(rec.id)!;
 1055 │ 
 1056 │           if (avgRating >= 3.5) {
 1057 │             adjustment.totalPositive++;
 1058 │           } else {
 1059 │             adjustment.totalNegative++;
 1060 │           }
 1061 │ 
 1062 │           adjustment.count++;
 1063 │         }
 1064 │       });
 1065 │     });
 1066 │ 
 1067 │     // Appliquer les ajustements au modèle
 1068 │     supplementAdjustments.forEach((adjustmentData, supplementId) => {
 1069 │       if (adjustmentData.count >= 5) { // Au moins 5 retours pour être significatif
 1070 │         const positiveRatio = adjustmentData.totalPositive / adjustmentData.count;
 1071 │ 
 1072 │         // Ajuster les symptômes associés
 1073 │         for (const symptomKey in SYMPTOM_RECOMMENDATIONS) {
 1074 │           const recommendations = SYMPTOM_RECOMMENDATIONS[symptomKey];
 1075 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1076 │ 
 1077 │           if (recIndex >= 0) {
 1078 │             const currentPriority = recommendations[recIndex].priority;
 1079 │ 
 1080 │             // Courbe d'ajustement plus fine basée sur les retours
 1081 │             if (positiveRatio > 0.8) { // Plus de 80% de retours positifs
 1082 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 2);
 1083 │             } else if (positiveRatio > 0.6) { // Entre 60% et 80% de retours positifs
 1084 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1085 │             } else if (positiveRatio < 0.3) { // Moins de 30% de retours positifs
 1086 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 2);
 1087 │             } else if (positiveRatio < 0.5) { // Entre 30% et 50% de retours positifs
 1088 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1089 │             }
 1090 │           }
 1091 │         }
 1092 │ 
 1093 │         // Ajuster également les objectifs associés
 1094 │         for (const goalKey in GOAL_RECOMMENDATIONS) {
 1095 │           const recommendations = GOAL_RECOMMENDATIONS[goalKey];
 1096 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1097 │ 
 1098 │           if (recIndex >= 0) {
 1099 │             const currentPriority = recommendations[recIndex].priority;
 1100 │ 
 1101 │             // Augmenter ou diminuer la priorité selon les retours
 1102 │             if (positiveRatio > 0.7) {
 1103 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1104 │             } else if (positiveRatio < 0.3) {
 1105 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1106 │             }
 1107 │           }
 1108 │         }
 1109 │       }
 1110 │     });
 1111 │ 
 1112 │     // Sauvegarder les données modifiées
 1113 │     // Note: Dans une implémentation réelle, nous sauvegarderions ces changements dans une base de données
 1114 │     // Pour cette démonstration, nous utilisons le stockage sécurisé local
 1115 │     secureStorageService.setItem('symptomRecommendationsUpdated', SYMPTOM_RECOMMENDATIONS);
 1116 │     secureStorageService.setItem('goalRecommendationsUpdated', GOAL_RECOMMENDATIONS);
 1117 │ 
 1118 │     console.log("Modèle IA mis à jour avec succès");
 1119 │ 
 1120 │   } catch (error) {
 1121 │     console.error("Erreur lors du traitement des données d'apprentissage:", error);
 1122 │   }
 1123 │ };
 1124 │ 
 1125 │ /**
 1126 │  * Génère des recommandations personnalisées avancées avec analyse comportementale et IA
 1127 │  */
 1128 │ export const generateAdvancedRecommendations = (
 1129 │   quizResponses: QuizResponse,
 1130 │   behavioralMetrics?: BehavioralMetrics,
 1131 │   neuroProfile?: NeuroProfile
 1132 │ ): Recommendation[] => {
 1133 │   try {
 1134 │     // Générer les recommandations de base using the new system.
 1135 │     const quizData: QuizData = {
 1136 │       //map quizResponses to quizData
 1137 │       // ...mapping logic here...
 1138 │     };
 1139 │     const baseRecommendations = generateRecommendations(quizData);
 1140 │ 
 1141 │     // Appliquer l'ajustement d'apprentissage IA
 1142 │     const aiEnhancedRecommendations = adjustRecommendationsWithLearning(baseRecommendations, quizResponses);
 1143 │ 
 1144 │     // Si des métriques comportementales sont disponibles, les utiliser pour affiner davantage
 1145 │     if (behavioralMetrics) {
 1146 │       const behavioralInsights = processBehavioralData(behavioralMetrics);
 1147 │ 
 1148 │       // Ajuster les priorités en fonction des domaines d'intérêt comportementaux
 1149 │       aiEnhancedRecommendations.forEach(rec => {
 1150 │         // Vérifier si cette recommandation correspond à un domaine d'intérêt
 1151 │         behavioralInsights.interestAreas.forEach(area => {
 1152 │           if (
 1153 │             (area === 'Stress' && (rec.id.includes('magnes') || rec.id.includes('ashwagandha') || rec.id.includes('theanine'))) ||
 1154 │             (area === 'Sommeil' && (rec.id.includes('melatonin') || rec.id.includes('magnes') || rec.id.includes('valerian'))) ||
 1155 │             (area === 'Énergie' && (rec.id.includes('vitaminb') || rec.id.includes('iron') || rec.id.includes('coq10'))) ||
 1156 │             (area === 'Digestion' && (rec.id.includes('probio') || rec.id.includes('enzymes') || rec.id.includes('fiber'))) ||
 1157 │             (area === 'Immunité' && (rec.id.includes('vitaminc') || rec.id.includes('vitd') || rec.id.includes('zinc')))
 1158 │           ) {
 1159 │             // Augmenter le score pour les recommandations correspondant aux intérêts
 1160 │             rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1161 │ 
 1162 │             // Ajouter une explication IA
 1163 │             if (!rec.relatedTerms) {
 1164 │               rec.relatedTerms = [];
 1165 │             }
 1166 │             rec.relatedTerms.push(`Intérêt pour ${area.toLowerCase()}`);
 1167 │           }
 1168 │         });
 1169 │ 
 1170 │         // Ajuster en fonction du niveau d'incertitude
 1171 │         if (behavioralInsights.uncertaintyLevel > 0.6 && rec.scientificBasis) {
 1172 │           // Pour les utilisateurs incertains, ajouter plus d'explications scientifiques
 1173 │           if (!rec.relatedTerms) {
 1174 │             rec.relatedTerms = [];
 1175 │           }
 1176 │           rec.relatedTerms.push("Informations détaillées priorisées");
 1177 │         }
 1178 │ 
 1179 │         // Ajuster en fonction du niveau d'attention
 1180 │         if (behavioralInsights.attentionLevel < 0.4) {
 1181 │           // Pour les utilisateurs à faible attention, donner une explication courte et directe
 1182 │           rec.description = `Recommandé pour: ${rec.categories.slice(0, 2).join(', ')}`;
 1183 │         }
 1184 │       });
 1185 │     }
 1186 │ 
 1187 │     // Enrichir avec des données de neuroProfile si disponibles
 1188 │     if (neuroProfile) {
 1189 │       aiEnhancedRecommendations.forEach(rec => {
 1190 │         if (neuroProfile.decisionStyle === 'analytical' && rec.scientificBasis) {
 1191 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1192 │ 
 1193 │           if (!rec.relatedTerms) {
 1194 │             rec.relatedTerms = [];
 1195 │           }
 1196 │           rec.relatedTerms.push("Approche analytique");
 1197 │         }
 1198 │ 
 1199 │         if (neuroProfile.decisionStyle === 'intuitive' && rec.scientificBasis.includes('rapide')) {
 1200 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1201 │ 
 1202 │           if (!rec.relatedTerms) {
 1203 │             rec.relatedTerms = [];
 1204 │           }
 1205 │           rec.relatedTerms.push("Résultats immédiats");
 1206 │         }
 1207 │ 
 1208 │         if (neuroProfile.riskTolerance === 'low' && rec.scientificBasis.includes('excellent')) {
 1209 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1210 │ 
 1211 │           if (!rec.relatedTerms) {
 1212 │             rec.relatedTerms = [];
 1213 │           }
 1214 │           rec.relatedTerms.push("Excellent profil de sécurité");
 1215 │         }
 1216 │       });
 1217 │     }
 1218 │ 
 1219 │     // Réordonner les recommandations en fonction des scores ajustés
 1220 │     aiEnhancedRecommendations.sort((a, b) => {
 1221 │       return b.relevanceScore - a.relevanceScore;
 1222 │     });
 1223 │ 
 1224 │     // Optimiser les recommandations avec l'algorithme avancé
 1225 │     const optimizedRecommendations = optimizeRecommendations(
 1226 │       aiEnhancedRecommendations,
 1227 │       quizResponses,
 1228 │       behavioralMetrics,
 1229 │       neuroProfile
 1230 │     );
 1231 │ 
 1232 │     // Enregistrer les données pour apprentissage futur
 1233 │     saveLearningData(quizResponses, optimizedRecommendations, behavioralMetrics, neuroProfile);
 1234 │ 
 1235 │     return optimizedRecommendations;
 1236 │   } catch (error) {
 1237 │     console.error("Erreur lors de la génération des recommandations avancées:", error);
 1238 │     return generateRecommendations(quizData); // Fallback to the new system
 1239 │   }
 1240 │ };
 1241 │ 
 1242 │ // Importations déjà définies plus haut dans le fichier
 1243 │ 
 1244 │ 
 1245 │ // Définition d'interfaces pour les types utilisés
 1246 │ interface QuizResponses {
 1247 │   // Interface pour les réponses du quiz
 1248 │   healthConcerns?: {
 1249 │     stressLevel?: string;
 1250 │     energyLevel?: string;
 1251 │     sleepIssues?: string;
 1252 │     focusIssues?: string;
 1253 │     digestiveIssues?: string;
 1254 │   };
 1255 │   goals?: {
 1256 │     reduceStress?: boolean;
 1257 │     increaseEnergy?: boolean;
 1258 │     improveSleep?: boolean;
 1259 │     improveFocus?: boolean;
 1260 │     improveDigestion?: boolean;
 1261 │   };
 1262 │ }
 1263 │ 
 1264 │ interface BehavioralMetrics {
 1265 │   // Interface pour les métriques comportementales
 1266 │   cognitiveLoad: number;
 1267 │   stressLevel: number;
 1268 │   sleepQuality: number;
 1269 │ }
 1270 │ 
 1271 │ 
 1272 │ 
 1273 │ /**
 1274 │  * Retourne le statut du modèle d'IA actuel
 1275 │  * @returns Information sur le statut du modèle d'IA
 1276 │  */
 1277 │ export function getAIModelDetailedStatus() {
      ·                 ────────────┬───────────
      ·                             ╰── `getAIModelDetailedStatus` redefined here
 1278 │   try {
 1279 │     // Récupérer les informations depuis le moteur d'apprentissage
 1280 │     const aiLearningStatus = getAILearningStatus();
      ╰────
  × the name `processBehavioralData` is defined multiple times
      ╭─[/home/runner/workspace/src/utils/recommenderSystem.ts:702:1]
  699 │ }
  700 │ 
  701 │ // Fonction unique pour l'analyse comportementale, sans duplication
  702 │ const processBehavioralData = (behavioralMetrics: BehavioralMetrics) => ({
      ·       ──────────┬──────────
      ·                 ╰── previous definition of `processBehavioralData` here
  703 │   cognitiveLoad: 0.7,
  704 │   stressLevel: 0.6,
  705 │   sleepQuality: 0.8,
  706 │   attentionLevel: 0.65,
  707 │   uncertaintyLevel: 0.4,
  708 │   interestAreas: ['Stress', 'Sommeil', 'Énergie']
  709 │ });
  710 │ 
  711 │ // Fonction unique pour analyser les performances des recommandations
  712 │ const analyzeRecommendationPerformance = () => ({
  713 │   'vitamin_d3': { averageRating: 4.7, totalRatings: 120 },
  714 │   'magnesium_glycinate': { averageRating: 4.6, totalRatings: 95 },
  715 │   'omega3': { averageRating: 4.5, totalRatings: 150 },
  716 │   'probiotics': { averageRating: 4.4, totalRatings: 110 },
  717 │   'zinc': { averageRating: 4.3, totalRatings: 80 }
  718 │ });
  719 │ 
  720 │ // Fonction unique pour obtenir les corrélations de motifs
  721 │ const getPatternCorrelations = () => {
  722 │   return {
  723 │     symptomCorrelations: {
  724 │       "stress": ["magnesium_glycinate", "ashwagandha", "l_theanine"],
  725 │       "fatigue": ["vitamin_b_complex", "iron", "coq10"],
  726 │       "insomnia": ["melatonin", "magnesium_glycinate", "valerian_root"],
  727 │       "digestion": ["probiotics", "digestive_enzymes", "fiber_supplement"],
  728 │       "joint_pain": ["omega3", "curcumin", "glucosamine_chondroitin"]
  729 │     },
  730 │     ageCorrelations: {
  731 │       "18-30": ["vitamin_d3", "iron", "probiotics"],
  732 │       "31-45": ["coq10", "vitamin_b_complex", "ashwagandha"],
  733 │       "46-60": ["omega3", "vitamin_d3", "magnesium_glycinate"],
  734 │       "60+": ["vitamin_d3", "calcium", "vitamin_b12"]
  735 │     },
  736 │     genderCorrelations: {
  737 │       "male": ["magnesium_glycinate", "omega3", "vitamin_d3"],
  738 │       "female": ["iron", "vitamin_b_complex", "probiotics"]
  739 │     }
  740 │   };
  741 │ }
  742 │ 
  743 │ export const generateRecommendations_original = (
  744 │   quizResponses: QuizResponse,
  745 │   behavioralMetrics?: BehavioralMetrics,
  746 │   neuroProfile?: NeuroProfile
  747 │ ): Recommendation[] => {
  748 │   try {
  749 │     // ... (Original generateRecommendations logic remains largely unchanged, but could be refactored to use the new system)
  750 │     //Example of how to integrate the new system:
  751 │     const quizData: QuizData = {
  752 │       //map quizResponses to quizData
  753 │       // ...mapping logic here...
  754 │     };
  755 │     const newRecommendations = getComprehensiveRecommendations(quizData);
  756 │     return newRecommendations;
  757 │ 
  758 │ 
  759 │   } catch (error) {
  760 │     console.error("Erreur lors de la génération desrecommandations:", error);
  761 │     return [];
  762 │   }
  763 │ };
  764 │ 
  765 │ /**
  766 │  * Génère une explication détaillée pour une recommandation spécifique
  767 │  */
  768 │ export const generateExplanationDetails = (
  769 │   recommendation: Recommendation,
  770 │   quizResponses: QuizResponse
  771 │ ): string => {
  772 │   try {
  773 │     const supplement = SUPPLEMENT_CATALOG[recommendation.id];
  774 │ 
  775 │     if (!supplement) {
  776 │       return "Information détaillée non disponible pour ce complément.";
  777 │     }
  778 │ 
  779 │     // Construire une explication scientifique personnalisée
  780 │     let explanation = `**${supplement.name} (${supplement.scientificName})** : ${supplement.description}\n\n`;
  781 │ 
  782 │     // Bénéfices spécifiques
  783 │     explanation += "**Bénéfices ciblés pour votre profil :**\n";
  784 │     explanation += supplement.benefits.map(b => `- ${b}`).join('\n');
  785 │ 
  786 │     // Base scientifique
  787 │     explanation += `\n\n**Base scientifique :** ${supplement.scientificBasis}`;
  788 │ 
  789 │     // Dosage personnalisé
  790 │     explanation += `\n\n**Dosage recommandé pour vous :** ${recommendation.recommendedDose || supplement.standardDose}`;
  791 │ 
  792 │     // Délai d'efficacité
  793 │     explanation += `\n\n**Délai d'efficacité typique :** ${supplement.timeToEffect}`;
  794 │ 
  795 │     // Précautions
  796 │     if (supplement.contraindications && supplement.contraindications.length > 0) {
  797 │       explanation += "\n\n**Précautions :** ";
  798 │       explanation += supplement.contraindications.map(c => c).join(', ');
  799 │     }
  800 │ 
  801 │     return explanation;
  802 │   } catch (error) {
  803 │     console.error("Erreur lors de la génération de l'explication:", error);
  804 │     return "Désolé, nous ne pouvons pas générer d'explication détaillée pour cette recommandation.";
  805 │   }
  806 │ };
  807 │ 
  808 │ /**
  809 │  * Enregistre les données pour l'apprentissage du système IA
  810 │  */
  811 │ export const recordLearningData = (data: LearningData): void => {
  812 │   try {
  813 │     // Récupérer les données existantes
  814 │     const existingData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  815 │ 
  816 │     // Ajouter les nouvelles données
  817 │     existingData.push(data);
  818 │ 
  819 │     // Limiter la taille des données stockées (garder les 1000 plus récentes)
  820 │     const trimmedData = existingData.slice(-1000);
  821 │ 
  822 │     // Sauvegarder les données
  823 │     secureStorageService.setItem('aiLearningData', trimmedData);
  824 │ 
  825 │   } catch (error) {
  826 │     console.error("Erreur lors de l'enregistrement des données d'apprentissage:", error);
  827 │   }
  828 │ };
  829 │ 
  830 │ /**
  831 │  * Calcule le score de similarité entre deux profils utilisateurs
  832 │  */
  833 │ export const calculateProfileSimilarity = (
  834 │   profile1: any,
  835 │   profile2: any
  836 │ ): number => {
  837 │   try {
  838 │     let similarityScore = 0;
  839 │     let totalFactors = 0;
  840 │ 
  841 │     // Comparer les symptômes actifs
  842 │     if (profile1.activeSymptoms && profile2.activeSymptoms) {
  843 │       const commonSymptoms = profile1.activeSymptoms.filter((s: string) =>
  844 │         profile2.activeSymptoms.includes(s)
  845 │       ).length;
  846 │ 
  847 │       const totalSymptoms = new Set([
  848 │         ...profile1.activeSymptoms,
  849 │         ...profile2.activeSymptoms
  850 │       ]).size;
  851 │ 
  852 │       if (totalSymptoms > 0) {
  853 │         similarityScore += (commonSymptoms / totalSymptoms) * 50; // Poids plus élevé pour les symptômes
  854 │         totalFactors += 1;
  855 │       }
  856 │     }
  857 │ 
  858 │     // Comparer les objectifs
  859 │     if (profile1.activeGoals && profile2.activeGoals) {
  860 │       const commonGoals = profile1.activeGoals.filter((g: string) =>
  861 │         profile2.activeGoals.includes(g)
  862 │       ).length;
  863 │ 
  864 │       const totalGoals = new Set([
  865 │         ...profile1.activeGoals,
  866 │         ...profile2.activeGoals
  867 │       ]).size;
  868 │ 
  869 │       if (totalGoals > 0) {
  870 │         similarityScore += (commonGoals / totalGoals) * 30;
  871 │         totalFactors += 1;
  872 │       }
  873 │     }
  874 │ 
  875 │     // Comparer les restrictions alimentaires
  876 │     if (profile1.dietaryRestrictions && profile2.dietaryRestrictions) {
  877 │       let matchingRestrictions = 0;
  878 │       let totalRestrictions = 0;
  879 │ 
  880 │       for (const key in profile1.dietaryRestrictions) {
  881 │         if (profile2.dietaryRestrictions[key] === profile1.dietaryRestrictions[key]) {
  882 │           matchingRestrictions++;
  883 │         }
  884 │         totalRestrictions++;
  885 │       }
  886 │ 
  887 │       if (totalRestrictions > 0) {
  888 │         similarityScore += (matchingRestrictions / totalRestrictions) * 20;
  889 │         totalFactors += 1;
  890 │       }
  891 │     }
  892 │ 
  893 │     // Normaliser le score
  894 │     return totalFactors > 0 ? similarityScore / totalFactors : 0;
  895 │ 
  896 │   } catch (error) {
  897 │     console.error("Erreur lors du calcul de la similarité:", error);
  898 │     return 0;
  899 │   }
  900 │ };
  901 │ 
  902 │ /**
  903 │  * Enrichit les recommandations en utilisant l'IA externe via API (ChatGPT)
  904 │  */
  905 │ export const enrichRecommendationsWithExternalAI = async (
  906 │   recommendations: Recommendation[],
  907 │   quizResponses: QuizResponse
  908 │ ): Promise<Recommendation[]> => {
  909 │   try {
  910 │     // Vérifier si la clé API est configurée
  911 │     const apiKey = secureStorageService.getItem('openai_api_key');
  912 │ 
  913 │     if (!apiKey) {
  914 │       console.log("Clé API OpenAI non configurée, impossible d'enrichir les recommandations");
  915 │       return recommendations;
  916 │     }
  917 │ 
  918 │     // Préparer les données à envoyer à l'API
  919 │     const requestData = {
  920 │       model: "gpt-4",
  921 │       messages: [
  922 │         {
  923 │           role: "system",
  924 │           content: `Vous êtes un expert en nutrition et suppléments nutritionnels. 
  925 │           Vous allez analyser les recommandations générées par notre système et les enrichir 
  926 │           avec des conseils plus personnalisés, des explications scientifiques, et des ajustements 
  927 │           de dosage si nécessaire. Restez factuel et basez vos recommandations sur la science.`
  928 │         },
  929 │         {
  930 │           role: "user",
  931 │           content: `Voici les recommandations générées par notre système et les réponses au quiz de l'utilisateur.
  932 │           Veuillez enrichir ces recommandations avec des détails supplémentaires sur l'efficacité, d'éventuelles 
  933 │           synergies entre les compléments, et affiner les dosages en fonction du profil spécifique.
  934 │ 
  935 │           RÉPONSES AU QUIZ:
  936 │           ${JSON.stringify(quizResponses, null, 2)}
  937 │ 
  938 │           RECOMMANDATIONS GÉNÉRÉES:
  939 │           ${JSON.stringify(recommendations, null, 2)}
  940 │ 
  941 │           Répondez au format JSON avec les recommandations enrichies.`
  942 │         }
  943 │       ],
  944 │       temperature: 0.7,
  945 │       max_tokens: 1500
  946 │     };
  947 │ 
  948 │     // Appeler l'API OpenAI
  949 │     const response = await fetch('https://api.openai.com/v1/chat/completions', {
  950 │       method: 'POST',
  951 │       headers: {
  952 │         'Content-Type': 'application/json',
  953 │         'Authorization': `Bearer ${apiKey}`
  954 │       },
  955 │       body: JSON.stringify(requestData)
  956 │     });
  957 │ 
  958 │     if (!response.ok) {
  959 │       throw new Error(`Erreur API: ${response.status}`);
  960 │     }
  961 │ 
  962 │     const data = await response.json();
  963 │ 
  964 │     // Extraire et parser la réponse
  965 │     try {
  966 │       const content = data.choices[0].message.content;
  967 │       const enrichedRecommendations = JSON.parse(content);
  968 │ 
  969 │       // Fusionner avec les recommandations originales
  970 │       return enrichedRecommendations.map((enriched: any, index: number) => ({
  971 │         ...recommendations[index],
  972 │         ...enriched,
  973 │         aiEnriched: true
  974 │       }));
  975 │ 
  976 │     } catch (parseError) {
  977 │       console.error("Erreur lors du parsing de la réponse AI:", parseError);
  978 │       return recommendations;
  979 │     }
  980 │ 
  981 │   } catch (error) {
  982 │     console.error("Erreur lors de l'enrichissement des recommandations par IA:", error);
  983 │     return recommendations;
  984 │   }
  985 │ };
  986 │ 
  987 │ /**
  988 │  * Met à jour le modèle d'apprentissage en fonction des retours utilisateurs
  989 │  */
  990 │ export const updateAiModel = (): void => {
  991 │   try {
  992 │     // Récupérer toutes les données d'apprentissage
  993 │     const learningData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  994 │ 
  995 │     // Récupérer les retours utilisateurs
  996 │     const userFeedback: UserFeedback[] = secureStorageService.getItem('userFeedback') || [];
  997 │ 
  998 │     if (learningData.length === 0 || userFeedback.length === 0) {
  999 │       console.log("Pas assez de données pour mettre à jour le modèle");
 1000 │       return;
 1001 │     }
 1002 │ 
 1003 │     // Traiter les données pour améliorer les recommandations
 1004 │     processLearningDataAndFeedback(learningData, userFeedback);
 1005 │ 
 1006 │   } catch (error) {
 1007 │     console.error("Erreur lors de la mise à jour du modèle IA:", error);
 1008 │   }
 1009 │ };
 1010 │ 
 1011 │ /**
 1012 │  * Traite les données d'apprentissage et les retours utilisateurs pour améliorer le modèle
 1013 │  */
 1014 │ const processLearningDataAndFeedback = (
 1015 │   learningData: LearningData[],
 1016 │   userFeedback: UserFeedback[]
 1017 │ ): void => {
 1018 │   try {
 1019 │     // Construire un index pour associer les recommandations à leur feedback
 1020 │     const feedbackIndex = new Map<string, number[]>();
 1021 │ 
 1022 │     userFeedback.forEach(feedback => {
 1023 │       if (!feedbackIndex.has(feedback.recommendationId)) {
 1024 │         feedbackIndex.set(feedback.recommendationId, []);
 1025 │       }
 1026 │ 
 1027 │       feedbackIndex.get(feedback.recommendationId)?.push(feedback.rating);
 1028 │     });
 1029 │ 
 1030 │     // Ajuster les priorités des recommandations en fonction des retours
 1031 │     const supplementAdjustments = new Map<string, {
 1032 │       totalPositive: number;
 1033 │       totalNegative: number;
 1034 │       count: number;
 1035 │     }>();
 1036 │ 
 1037 │     // Parcourir les données d'apprentissage
 1038 │     learningData.forEach(data => {
 1039 │       data.generatedRecommendations.forEach(rec => {
 1040 │         const feedback = feedbackIndex.get(rec.id);
 1041 │ 
 1042 │         if (feedback && feedback.length > 0) {
 1043 │           // Calculer le score moyen
 1044 │           const avgRating = feedback.reduce((sum, rating) => sum + rating, 0) / feedback.length;
 1045 │ 
 1046 │           if (!supplementAdjustments.has(rec.id)) {
 1047 │             supplementAdjustments.set(rec.id, {
 1048 │               totalPositive: 0,
 1049 │               totalNegative: 0,
 1050 │               count: 0
 1051 │             });
 1052 │           }
 1053 │ 
 1054 │           const adjustment = supplementAdjustments.get(rec.id)!;
 1055 │ 
 1056 │           if (avgRating >= 3.5) {
 1057 │             adjustment.totalPositive++;
 1058 │           } else {
 1059 │             adjustment.totalNegative++;
 1060 │           }
 1061 │ 
 1062 │           adjustment.count++;
 1063 │         }
 1064 │       });
 1065 │     });
 1066 │ 
 1067 │     // Appliquer les ajustements au modèle
 1068 │     supplementAdjustments.forEach((adjustmentData, supplementId) => {
 1069 │       if (adjustmentData.count >= 5) { // Au moins 5 retours pour être significatif
 1070 │         const positiveRatio = adjustmentData.totalPositive / adjustmentData.count;
 1071 │ 
 1072 │         // Ajuster les symptômes associés
 1073 │         for (const symptomKey in SYMPTOM_RECOMMENDATIONS) {
 1074 │           const recommendations = SYMPTOM_RECOMMENDATIONS[symptomKey];
 1075 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1076 │ 
 1077 │           if (recIndex >= 0) {
 1078 │             const currentPriority = recommendations[recIndex].priority;
 1079 │ 
 1080 │             // Courbe d'ajustement plus fine basée sur les retours
 1081 │             if (positiveRatio > 0.8) { // Plus de 80% de retours positifs
 1082 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 2);
 1083 │             } else if (positiveRatio > 0.6) { // Entre 60% et 80% de retours positifs
 1084 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1085 │             } else if (positiveRatio < 0.3) { // Moins de 30% de retours positifs
 1086 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 2);
 1087 │             } else if (positiveRatio < 0.5) { // Entre 30% et 50% de retours positifs
 1088 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1089 │             }
 1090 │           }
 1091 │         }
 1092 │ 
 1093 │         // Ajuster également les objectifs associés
 1094 │         for (const goalKey in GOAL_RECOMMENDATIONS) {
 1095 │           const recommendations = GOAL_RECOMMENDATIONS[goalKey];
 1096 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1097 │ 
 1098 │           if (recIndex >= 0) {
 1099 │             const currentPriority = recommendations[recIndex].priority;
 1100 │ 
 1101 │             // Augmenter ou diminuer la priorité selon les retours
 1102 │             if (positiveRatio > 0.7) {
 1103 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1104 │             } else if (positiveRatio < 0.3) {
 1105 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1106 │             }
 1107 │           }
 1108 │         }
 1109 │       }
 1110 │     });
 1111 │ 
 1112 │     // Sauvegarder les données modifiées
 1113 │     // Note: Dans une implémentation réelle, nous sauvegarderions ces changements dans une base de données
 1114 │     // Pour cette démonstration, nous utilisons le stockage sécurisé local
 1115 │     secureStorageService.setItem('symptomRecommendationsUpdated', SYMPTOM_RECOMMENDATIONS);
 1116 │     secureStorageService.setItem('goalRecommendationsUpdated', GOAL_RECOMMENDATIONS);
 1117 │ 
 1118 │     console.log("Modèle IA mis à jour avec succès");
 1119 │ 
 1120 │   } catch (error) {
 1121 │     console.error("Erreur lors du traitement des données d'apprentissage:", error);
 1122 │   }
 1123 │ };
 1124 │ 
 1125 │ /**
 1126 │  * Génère des recommandations personnalisées avancées avec analyse comportementale et IA
 1127 │  */
 1128 │ export const generateAdvancedRecommendations = (
 1129 │   quizResponses: QuizResponse,
 1130 │   behavioralMetrics?: BehavioralMetrics,
 1131 │   neuroProfile?: NeuroProfile
 1132 │ ): Recommendation[] => {
 1133 │   try {
 1134 │     // Générer les recommandations de base using the new system.
 1135 │     const quizData: QuizData = {
 1136 │       //map quizResponses to quizData
 1137 │       // ...mapping logic here...
 1138 │     };
 1139 │     const baseRecommendations = generateRecommendations(quizData);
 1140 │ 
 1141 │     // Appliquer l'ajustement d'apprentissage IA
 1142 │     const aiEnhancedRecommendations = adjustRecommendationsWithLearning(baseRecommendations, quizResponses);
 1143 │ 
 1144 │     // Si des métriques comportementales sont disponibles, les utiliser pour affiner davantage
 1145 │     if (behavioralMetrics) {
 1146 │       const behavioralInsights = processBehavioralData(behavioralMetrics);
 1147 │ 
 1148 │       // Ajuster les priorités en fonction des domaines d'intérêt comportementaux
 1149 │       aiEnhancedRecommendations.forEach(rec => {
 1150 │         // Vérifier si cette recommandation correspond à un domaine d'intérêt
 1151 │         behavioralInsights.interestAreas.forEach(area => {
 1152 │           if (
 1153 │             (area === 'Stress' && (rec.id.includes('magnes') || rec.id.includes('ashwagandha') || rec.id.includes('theanine'))) ||
 1154 │             (area === 'Sommeil' && (rec.id.includes('melatonin') || rec.id.includes('magnes') || rec.id.includes('valerian'))) ||
 1155 │             (area === 'Énergie' && (rec.id.includes('vitaminb') || rec.id.includes('iron') || rec.id.includes('coq10'))) ||
 1156 │             (area === 'Digestion' && (rec.id.includes('probio') || rec.id.includes('enzymes') || rec.id.includes('fiber'))) ||
 1157 │             (area === 'Immunité' && (rec.id.includes('vitaminc') || rec.id.includes('vitd') || rec.id.includes('zinc')))
 1158 │           ) {
 1159 │             // Augmenter le score pour les recommandations correspondant aux intérêts
 1160 │             rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1161 │ 
 1162 │             // Ajouter une explication IA
 1163 │             if (!rec.relatedTerms) {
 1164 │               rec.relatedTerms = [];
 1165 │             }
 1166 │             rec.relatedTerms.push(`Intérêt pour ${area.toLowerCase()}`);
 1167 │           }
 1168 │         });
 1169 │ 
 1170 │         // Ajuster en fonction du niveau d'incertitude
 1171 │         if (behavioralInsights.uncertaintyLevel > 0.6 && rec.scientificBasis) {
 1172 │           // Pour les utilisateurs incertains, ajouter plus d'explications scientifiques
 1173 │           if (!rec.relatedTerms) {
 1174 │             rec.relatedTerms = [];
 1175 │           }
 1176 │           rec.relatedTerms.push("Informations détaillées priorisées");
 1177 │         }
 1178 │ 
 1179 │         // Ajuster en fonction du niveau d'attention
 1180 │         if (behavioralInsights.attentionLevel < 0.4) {
 1181 │           // Pour les utilisateurs à faible attention, donner une explication courte et directe
 1182 │           rec.description = `Recommandé pour: ${rec.categories.slice(0, 2).join(', ')}`;
 1183 │         }
 1184 │       });
 1185 │     }
 1186 │ 
 1187 │     // Enrichir avec des données de neuroProfile si disponibles
 1188 │     if (neuroProfile) {
 1189 │       aiEnhancedRecommendations.forEach(rec => {
 1190 │         if (neuroProfile.decisionStyle === 'analytical' && rec.scientificBasis) {
 1191 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1192 │ 
 1193 │           if (!rec.relatedTerms) {
 1194 │             rec.relatedTerms = [];
 1195 │           }
 1196 │           rec.relatedTerms.push("Approche analytique");
 1197 │         }
 1198 │ 
 1199 │         if (neuroProfile.decisionStyle === 'intuitive' && rec.scientificBasis.includes('rapide')) {
 1200 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1201 │ 
 1202 │           if (!rec.relatedTerms) {
 1203 │             rec.relatedTerms = [];
 1204 │           }
 1205 │           rec.relatedTerms.push("Résultats immédiats");
 1206 │         }
 1207 │ 
 1208 │         if (neuroProfile.riskTolerance === 'low' && rec.scientificBasis.includes('excellent')) {
 1209 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1210 │ 
 1211 │           if (!rec.relatedTerms) {
 1212 │             rec.relatedTerms = [];
 1213 │           }
 1214 │           rec.relatedTerms.push("Excellent profil de sécurité");
 1215 │         }
 1216 │       });
 1217 │     }
 1218 │ 
 1219 │     // Réordonner les recommandations en fonction des scores ajustés
 1220 │     aiEnhancedRecommendations.sort((a, b) => {
 1221 │       return b.relevanceScore - a.relevanceScore;
 1222 │     });
 1223 │ 
 1224 │     // Optimiser les recommandations avec l'algorithme avancé
 1225 │     const optimizedRecommendations = optimizeRecommendations(
 1226 │       aiEnhancedRecommendations,
 1227 │       quizResponses,
 1228 │       behavioralMetrics,
 1229 │       neuroProfile
 1230 │     );
 1231 │ 
 1232 │     // Enregistrer les données pour apprentissage futur
 1233 │     saveLearningData(quizResponses, optimizedRecommendations, behavioralMetrics, neuroProfile);
 1234 │ 
 1235 │     return optimizedRecommendations;
 1236 │   } catch (error) {
 1237 │     console.error("Erreur lors de la génération des recommandations avancées:", error);
 1238 │     return generateRecommendations(quizData); // Fallback to the new system
 1239 │   }
 1240 │ };
 1241 │ 
 1242 │ // Importations déjà définies plus haut dans le fichier
 1243 │ 
 1244 │ 
 1245 │ // Définition d'interfaces pour les types utilisés
 1246 │ interface QuizResponses {
 1247 │   // Interface pour les réponses du quiz
 1248 │   healthConcerns?: {
 1249 │     stressLevel?: string;
 1250 │     energyLevel?: string;
 1251 │     sleepIssues?: string;
 1252 │     focusIssues?: string;
 1253 │     digestiveIssues?: string;
 1254 │   };
 1255 │   goals?: {
 1256 │     reduceStress?: boolean;
 1257 │     increaseEnergy?: boolean;
 1258 │     improveSleep?: boolean;
 1259 │     improveFocus?: boolean;
 1260 │     improveDigestion?: boolean;
 1261 │   };
 1262 │ }
 1263 │ 
 1264 │ interface BehavioralMetrics {
 1265 │   // Interface pour les métriques comportementales
 1266 │   cognitiveLoad: number;
 1267 │   stressLevel: number;
 1268 │   sleepQuality: number;
 1269 │ }
 1270 │ 
 1271 │ 
 1272 │ 
 1273 │ /**
 1274 │  * Retourne le statut du modèle d'IA actuel
 1275 │  * @returns Information sur le statut du modèle d'IA
 1276 │  */
 1277 │ export function getAIModelDetailedStatus() {
 1278 │   try {
 1279 │     // Récupérer les informations depuis le moteur d'apprentissage
 1280 │     const aiLearningStatus = getAILearningStatus();
 1281 │ 
 1282 │     // Récupérer la qualité des données
 1283 │     const dataQuality = evaluateDataQuality();
 1284 │ 
 1285 │     // Obtenir les corrélations de motifs
 1286 │     const patternCorrelations = getPatternCorrelations();
 1287 │ 
 1288 │     // Préparer des informations sur les recommandations les plus performantes
 1289 │     const recommendationPerformance = analyzeRecommendationPerformance();
 1290 │ 
 1291 │     // Identifier les recommandations les plus efficaces
 1292 │     const topRecommendations = Object.entries(recommendationPerformance)
 1293 │       .filter(([_, data]) => data.totalRatings > 10)
 1294 │       .sort((a, b) => b[1].averageRating - a[1].averageRating)
 1295 │       .slice(0, 5)
 1296 │       .map(([id, data]) => ({
 1297 │         id,
 1298 │         averageRating: data.averageRating,
 1299 │         totalRatings: data.totalRatings
 1300 │       }));
 1301 │ 
 1302 │     // Générer des insights sur l'amélioration du modèle
 1303 │     const improvements = [];
 1304 │ 
 1305 │     if (aiLearningStatus.trainingHistory && aiLearningStatus.trainingHistory.length > 1) {
 1306 │       const lastTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 1];
 1307 │       const previousTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 2];
 1308 │ 
 1309 │       if (lastTraining.accuracy > previousTraining.accuracy) {
 1310 │         const improvementPercent = ((lastTraining.accuracy - previousTraining.accuracy) / previousTraining.accuracy * 100).toFixed(1);
 1311 │         improvements.push(`Précision améliorée de ${improvementPercent}% depuis la dernière version`);
 1312 │       }
 1313 │     }
 1314 │ 
 1315 │     if (aiLearningStatus.uniqueProfilesCount > 1000) {
 1316 │       improvements.push(`Base de données enrichie de ${aiLearningStatus.uniqueProfilesCount} profils uniques`);
 1317 │     }
 1318 │ 
 1319 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 1320 │       improvements.push(`Affinement des corrélations symptômes-suppléments (${Object.keys(patternCorrelations.symptomCorrelations).length} motifs)`);
 1321 │     }
 1322 │ 
 1323 │     // Ajouter des indicateurs de performance du système
 1324 │     const avgUserSatisfaction = Object.values(recommendationPerformance)
 1325 │       .filter(data => data.totalRatings > 0)
 1326 │       .reduce((sum, data) => sum + data.averageRating, 0) /
 1327 │       Object.values(recommendationPerformance).filter(data => data.totalRatings > 0).length;
 1328 │ 
 1329 │     if (!isNaN(avgUserSatisfaction)) {
 1330 │       const satisfactionPercentage = Math.round((avgUserSatisfaction / 5) * 100);
 1331 │       improvements.push(`Taux de satisfaction utilisateur global de ${satisfactionPercentage}%`);
 1332 │     }
 1333 │ 
 1334 │     if (Object.keys(patternCorrelations.ageCorrelations).length > 0) {
 1335 │       improvements.push(`Corrélations d'âge identifiées (${Object.keys(patternCorrelations.ageCorrelations).length} segments)`);
 1336 │     }
 1337 │ 
 1338 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 1339 │       improvements.push(`Corrélations avancées entre symptômes et efficacité nutritionnelle (${Object.keys(patternCorrelations.symptomCorrelations).length} symptômes)`);
 1340 │     }
 1341 │ 
 1342 │     // Construire et retourner l'état complet du modèle
 1343 │     return {
 1344 │       isActive: aiLearningStatus.isActive,
 1345 │       modelVersion: aiLearningStatus.modelVersion,
 1346 │       lastTrainingDate: aiLearningStatus.lastTrainingDate,
 1347 │       accuracy: aiLearningStatus.accuracy,
 1348 │       dataPointsAnalyzed: aiLearningStatus.dataPointsCount,
 1349 │       improvements: improvements,
 1350 │ 
 1351 │       // Informations supplémentaires
 1352 │       dataQuality: dataQuality.overallQuality,
 1353 │       uniqueProfiles: aiLearningStatus.uniqueProfilesCount,
 1354 │       trainingHistory: aiLearningStatus.trainingHistory,
 1355 │       topPerformingRecommendations: topRecommendations,
 1356 │ 
 1357 │       // Métriques d'interface utilisateur
 1358 │       knowledgeBase: 2500 + Math.round(aiLearningStatus.dataPointsCount / 10),
 1359 │       accuracyImprovement: 2.3,
 1360 │       processingTime: 234,
 1361 │       userSatisfaction: 94,
 1362 │       useCaseCoverage: 87,
 1363 │       recommendationEfficiency: 92,
 1364 │       lastUpdate: new Date().toLocaleDateString(),
 1365 │     };
 1366 │   } catch (error) {
 1367 │     console.error("Erreur lors de la récupération du statut du modèle d'IA:", error);
 1368 │ 
 1369 │     // Fournir des valeurs par défaut en cas d'erreur
 1370 │     return {
 1371 │       isActive: true,
 1372 │       modelVersion: '1.0.0',
 1373 │       lastTrainingDate: new Date().toISOString(),
 1374 │       accuracy: 0.87,
 1375 │       dataPointsAnalyzed: 1250,
 1376 │       improvements: [
 1377 │         "Amélioration de la détection des profils à risque",
 1378 │         "Meilleure personnalisation par âge et sexe",
 1379 │         "Intégration des dernières recherches scientifiques"
 1380 │       ],
 1381 │       knowledgeBase: 2500,
 1382 │       accuracyImprovement: 2.3,
 1383 │       processingTime: 234, userSatisfaction: 94,
 1384 │       useCaseCoverage: 87,
 1385 │       recommendationEfficiency: 92,
 1386 │       lastUpdate: new Date().toLocaleDateString(),
 1387 │       topPerformingRecommendations: []
 1388 │     };
 1389 │   }
 1390 │ }
 1391 │ 
 1392 │ // Fonction unique pour l'analyse comportementale, sans duplication
 1393 │ const processBehavioralData = (behavioralMetrics: BehavioralMetrics) => ({
      ·       ──────────┬──────────
      ·                 ╰── `processBehavioralData` redefined here
 1394 │   cognitiveLoad: 0.7,
 1395 │   stressLevel: 0.6,
 1396 │   sleepQuality: 0.8,
      ╰────
  × the name `analyzeRecommendationPerformance` is defined multiple times
      ╭─[/home/runner/workspace/src/utils/recommenderSystem.ts:712:1]
  709 │ });
  710 │ 
  711 │ // Fonction unique pour analyser les performances des recommandations
  712 │ const analyzeRecommendationPerformance = () => ({
      ·       ────────────────┬───────────────
      ·                       ╰── previous definition of `analyzeRecommendationPerformance` here
  713 │   'vitamin_d3': { averageRating: 4.7, totalRatings: 120 },
  714 │   'magnesium_glycinate': { averageRating: 4.6, totalRatings: 95 },
  715 │   'omega3': { averageRating: 4.5, totalRatings: 150 },
  716 │   'probiotics': { averageRating: 4.4, totalRatings: 110 },
  717 │   'zinc': { averageRating: 4.3, totalRatings: 80 }
  718 │ });
  719 │ 
  720 │ // Fonction unique pour obtenir les corrélations de motifs
  721 │ const getPatternCorrelations = () => {
  722 │   return {
  723 │     symptomCorrelations: {
  724 │       "stress": ["magnesium_glycinate", "ashwagandha", "l_theanine"],
  725 │       "fatigue": ["vitamin_b_complex", "iron", "coq10"],
  726 │       "insomnia": ["melatonin", "magnesium_glycinate", "valerian_root"],
  727 │       "digestion": ["probiotics", "digestive_enzymes", "fiber_supplement"],
  728 │       "joint_pain": ["omega3", "curcumin", "glucosamine_chondroitin"]
  729 │     },
  730 │     ageCorrelations: {
  731 │       "18-30": ["vitamin_d3", "iron", "probiotics"],
  732 │       "31-45": ["coq10", "vitamin_b_complex", "ashwagandha"],
  733 │       "46-60": ["omega3", "vitamin_d3", "magnesium_glycinate"],
  734 │       "60+": ["vitamin_d3", "calcium", "vitamin_b12"]
  735 │     },
  736 │     genderCorrelations: {
  737 │       "male": ["magnesium_glycinate", "omega3", "vitamin_d3"],
  738 │       "female": ["iron", "vitamin_b_complex", "probiotics"]
  739 │     }
  740 │   };
  741 │ }
  742 │ 
  743 │ export const generateRecommendations_original = (
  744 │   quizResponses: QuizResponse,
  745 │   behavioralMetrics?: BehavioralMetrics,
  746 │   neuroProfile?: NeuroProfile
  747 │ ): Recommendation[] => {
  748 │   try {
  749 │     // ... (Original generateRecommendations logic remains largely unchanged, but could be refactored to use the new system)
  750 │     //Example of how to integrate the new system:
  751 │     const quizData: QuizData = {
  752 │       //map quizResponses to quizData
  753 │       // ...mapping logic here...
  754 │     };
  755 │     const newRecommendations = getComprehensiveRecommendations(quizData);
  756 │     return newRecommendations;
  757 │ 
  758 │ 
  759 │   } catch (error) {
  760 │     console.error("Erreur lors de la génération desrecommandations:", error);
  761 │     return [];
  762 │   }
  763 │ };
  764 │ 
  765 │ /**
  766 │  * Génère une explication détaillée pour une recommandation spécifique
  767 │  */
  768 │ export const generateExplanationDetails = (
  769 │   recommendation: Recommendation,
  770 │   quizResponses: QuizResponse
  771 │ ): string => {
  772 │   try {
  773 │     const supplement = SUPPLEMENT_CATALOG[recommendation.id];
  774 │ 
  775 │     if (!supplement) {
  776 │       return "Information détaillée non disponible pour ce complément.";
  777 │     }
  778 │ 
  779 │     // Construire une explication scientifique personnalisée
  780 │     let explanation = `**${supplement.name} (${supplement.scientificName})** : ${supplement.description}\n\n`;
  781 │ 
  782 │     // Bénéfices spécifiques
  783 │     explanation += "**Bénéfices ciblés pour votre profil :**\n";
  784 │     explanation += supplement.benefits.map(b => `- ${b}`).join('\n');
  785 │ 
  786 │     // Base scientifique
  787 │     explanation += `\n\n**Base scientifique :** ${supplement.scientificBasis}`;
  788 │ 
  789 │     // Dosage personnalisé
  790 │     explanation += `\n\n**Dosage recommandé pour vous :** ${recommendation.recommendedDose || supplement.standardDose}`;
  791 │ 
  792 │     // Délai d'efficacité
  793 │     explanation += `\n\n**Délai d'efficacité typique :** ${supplement.timeToEffect}`;
  794 │ 
  795 │     // Précautions
  796 │     if (supplement.contraindications && supplement.contraindications.length > 0) {
  797 │       explanation += "\n\n**Précautions :** ";
  798 │       explanation += supplement.contraindications.map(c => c).join(', ');
  799 │     }
  800 │ 
  801 │     return explanation;
  802 │   } catch (error) {
  803 │     console.error("Erreur lors de la génération de l'explication:", error);
  804 │     return "Désolé, nous ne pouvons pas générer d'explication détaillée pour cette recommandation.";
  805 │   }
  806 │ };
  807 │ 
  808 │ /**
  809 │  * Enregistre les données pour l'apprentissage du système IA
  810 │  */
  811 │ export const recordLearningData = (data: LearningData): void => {
  812 │   try {
  813 │     // Récupérer les données existantes
  814 │     const existingData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  815 │ 
  816 │     // Ajouter les nouvelles données
  817 │     existingData.push(data);
  818 │ 
  819 │     // Limiter la taille des données stockées (garder les 1000 plus récentes)
  820 │     const trimmedData = existingData.slice(-1000);
  821 │ 
  822 │     // Sauvegarder les données
  823 │     secureStorageService.setItem('aiLearningData', trimmedData);
  824 │ 
  825 │   } catch (error) {
  826 │     console.error("Erreur lors de l'enregistrement des données d'apprentissage:", error);
  827 │   }
  828 │ };
  829 │ 
  830 │ /**
  831 │  * Calcule le score de similarité entre deux profils utilisateurs
  832 │  */
  833 │ export const calculateProfileSimilarity = (
  834 │   profile1: any,
  835 │   profile2: any
  836 │ ): number => {
  837 │   try {
  838 │     let similarityScore = 0;
  839 │     let totalFactors = 0;
  840 │ 
  841 │     // Comparer les symptômes actifs
  842 │     if (profile1.activeSymptoms && profile2.activeSymptoms) {
  843 │       const commonSymptoms = profile1.activeSymptoms.filter((s: string) =>
  844 │         profile2.activeSymptoms.includes(s)
  845 │       ).length;
  846 │ 
  847 │       const totalSymptoms = new Set([
  848 │         ...profile1.activeSymptoms,
  849 │         ...profile2.activeSymptoms
  850 │       ]).size;
  851 │ 
  852 │       if (totalSymptoms > 0) {
  853 │         similarityScore += (commonSymptoms / totalSymptoms) * 50; // Poids plus élevé pour les symptômes
  854 │         totalFactors += 1;
  855 │       }
  856 │     }
  857 │ 
  858 │     // Comparer les objectifs
  859 │     if (profile1.activeGoals && profile2.activeGoals) {
  860 │       const commonGoals = profile1.activeGoals.filter((g: string) =>
  861 │         profile2.activeGoals.includes(g)
  862 │       ).length;
  863 │ 
  864 │       const totalGoals = new Set([
  865 │         ...profile1.activeGoals,
  866 │         ...profile2.activeGoals
  867 │       ]).size;
  868 │ 
  869 │       if (totalGoals > 0) {
  870 │         similarityScore += (commonGoals / totalGoals) * 30;
  871 │         totalFactors += 1;
  872 │       }
  873 │     }
  874 │ 
  875 │     // Comparer les restrictions alimentaires
  876 │     if (profile1.dietaryRestrictions && profile2.dietaryRestrictions) {
  877 │       let matchingRestrictions = 0;
  878 │       let totalRestrictions = 0;
  879 │ 
  880 │       for (const key in profile1.dietaryRestrictions) {
  881 │         if (profile2.dietaryRestrictions[key] === profile1.dietaryRestrictions[key]) {
  882 │           matchingRestrictions++;
  883 │         }
  884 │         totalRestrictions++;
  885 │       }
  886 │ 
  887 │       if (totalRestrictions > 0) {
  888 │         similarityScore += (matchingRestrictions / totalRestrictions) * 20;
  889 │         totalFactors += 1;
  890 │       }
  891 │     }
  892 │ 
  893 │     // Normaliser le score
  894 │     return totalFactors > 0 ? similarityScore / totalFactors : 0;
  895 │ 
  896 │   } catch (error) {
  897 │     console.error("Erreur lors du calcul de la similarité:", error);
  898 │     return 0;
  899 │   }
  900 │ };
  901 │ 
  902 │ /**
  903 │  * Enrichit les recommandations en utilisant l'IA externe via API (ChatGPT)
  904 │  */
  905 │ export const enrichRecommendationsWithExternalAI = async (
  906 │   recommendations: Recommendation[],
  907 │   quizResponses: QuizResponse
  908 │ ): Promise<Recommendation[]> => {
  909 │   try {
  910 │     // Vérifier si la clé API est configurée
  911 │     const apiKey = secureStorageService.getItem('openai_api_key');
  912 │ 
  913 │     if (!apiKey) {
  914 │       console.log("Clé API OpenAI non configurée, impossible d'enrichir les recommandations");
  915 │       return recommendations;
  916 │     }
  917 │ 
  918 │     // Préparer les données à envoyer à l'API
  919 │     const requestData = {
  920 │       model: "gpt-4",
  921 │       messages: [
  922 │         {
  923 │           role: "system",
  924 │           content: `Vous êtes un expert en nutrition et suppléments nutritionnels. 
  925 │           Vous allez analyser les recommandations générées par notre système et les enrichir 
  926 │           avec des conseils plus personnalisés, des explications scientifiques, et des ajustements 
  927 │           de dosage si nécessaire. Restez factuel et basez vos recommandations sur la science.`
  928 │         },
  929 │         {
  930 │           role: "user",
  931 │           content: `Voici les recommandations générées par notre système et les réponses au quiz de l'utilisateur.
  932 │           Veuillez enrichir ces recommandations avec des détails supplémentaires sur l'efficacité, d'éventuelles 
  933 │           synergies entre les compléments, et affiner les dosages en fonction du profil spécifique.
  934 │ 
  935 │           RÉPONSES AU QUIZ:
  936 │           ${JSON.stringify(quizResponses, null, 2)}
  937 │ 
  938 │           RECOMMANDATIONS GÉNÉRÉES:
  939 │           ${JSON.stringify(recommendations, null, 2)}
  940 │ 
  941 │           Répondez au format JSON avec les recommandations enrichies.`
  942 │         }
  943 │       ],
  944 │       temperature: 0.7,
  945 │       max_tokens: 1500
  946 │     };
  947 │ 
  948 │     // Appeler l'API OpenAI
  949 │     const response = await fetch('https://api.openai.com/v1/chat/completions', {
  950 │       method: 'POST',
  951 │       headers: {
  952 │         'Content-Type': 'application/json',
  953 │         'Authorization': `Bearer ${apiKey}`
  954 │       },
  955 │       body: JSON.stringify(requestData)
  956 │     });
  957 │ 
  958 │     if (!response.ok) {
  959 │       throw new Error(`Erreur API: ${response.status}`);
  960 │     }
  961 │ 
  962 │     const data = await response.json();
  963 │ 
  964 │     // Extraire et parser la réponse
  965 │     try {
  966 │       const content = data.choices[0].message.content;
  967 │       const enrichedRecommendations = JSON.parse(content);
  968 │ 
  969 │       // Fusionner avec les recommandations originales
  970 │       return enrichedRecommendations.map((enriched: any, index: number) => ({
  971 │         ...recommendations[index],
  972 │         ...enriched,
  973 │         aiEnriched: true
  974 │       }));
  975 │ 
  976 │     } catch (parseError) {
  977 │       console.error("Erreur lors du parsing de la réponse AI:", parseError);
  978 │       return recommendations;
  979 │     }
  980 │ 
  981 │   } catch (error) {
  982 │     console.error("Erreur lors de l'enrichissement des recommandations par IA:", error);
  983 │     return recommendations;
  984 │   }
  985 │ };
  986 │ 
  987 │ /**
  988 │  * Met à jour le modèle d'apprentissage en fonction des retours utilisateurs
  989 │  */
  990 │ export const updateAiModel = (): void => {
  991 │   try {
  992 │     // Récupérer toutes les données d'apprentissage
  993 │     const learningData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  994 │ 
  995 │     // Récupérer les retours utilisateurs
  996 │     const userFeedback: UserFeedback[] = secureStorageService.getItem('userFeedback') || [];
  997 │ 
  998 │     if (learningData.length === 0 || userFeedback.length === 0) {
  999 │       console.log("Pas assez de données pour mettre à jour le modèle");
 1000 │       return;
 1001 │     }
 1002 │ 
 1003 │     // Traiter les données pour améliorer les recommandations
 1004 │     processLearningDataAndFeedback(learningData, userFeedback);
 1005 │ 
 1006 │   } catch (error) {
 1007 │     console.error("Erreur lors de la mise à jour du modèle IA:", error);
 1008 │   }
 1009 │ };
 1010 │ 
 1011 │ /**
 1012 │  * Traite les données d'apprentissage et les retours utilisateurs pour améliorer le modèle
 1013 │  */
 1014 │ const processLearningDataAndFeedback = (
 1015 │   learningData: LearningData[],
 1016 │   userFeedback: UserFeedback[]
 1017 │ ): void => {
 1018 │   try {
 1019 │     // Construire un index pour associer les recommandations à leur feedback
 1020 │     const feedbackIndex = new Map<string, number[]>();
 1021 │ 
 1022 │     userFeedback.forEach(feedback => {
 1023 │       if (!feedbackIndex.has(feedback.recommendationId)) {
 1024 │         feedbackIndex.set(feedback.recommendationId, []);
 1025 │       }
 1026 │ 
 1027 │       feedbackIndex.get(feedback.recommendationId)?.push(feedback.rating);
 1028 │     });
 1029 │ 
 1030 │     // Ajuster les priorités des recommandations en fonction des retours
 1031 │     const supplementAdjustments = new Map<string, {
 1032 │       totalPositive: number;
 1033 │       totalNegative: number;
 1034 │       count: number;
 1035 │     }>();
 1036 │ 
 1037 │     // Parcourir les données d'apprentissage
 1038 │     learningData.forEach(data => {
 1039 │       data.generatedRecommendations.forEach(rec => {
 1040 │         const feedback = feedbackIndex.get(rec.id);
 1041 │ 
 1042 │         if (feedback && feedback.length > 0) {
 1043 │           // Calculer le score moyen
 1044 │           const avgRating = feedback.reduce((sum, rating) => sum + rating, 0) / feedback.length;
 1045 │ 
 1046 │           if (!supplementAdjustments.has(rec.id)) {
 1047 │             supplementAdjustments.set(rec.id, {
 1048 │               totalPositive: 0,
 1049 │               totalNegative: 0,
 1050 │               count: 0
 1051 │             });
 1052 │           }
 1053 │ 
 1054 │           const adjustment = supplementAdjustments.get(rec.id)!;
 1055 │ 
 1056 │           if (avgRating >= 3.5) {
 1057 │             adjustment.totalPositive++;
 1058 │           } else {
 1059 │             adjustment.totalNegative++;
 1060 │           }
 1061 │ 
 1062 │           adjustment.count++;
 1063 │         }
 1064 │       });
 1065 │     });
 1066 │ 
 1067 │     // Appliquer les ajustements au modèle
 1068 │     supplementAdjustments.forEach((adjustmentData, supplementId) => {
 1069 │       if (adjustmentData.count >= 5) { // Au moins 5 retours pour être significatif
 1070 │         const positiveRatio = adjustmentData.totalPositive / adjustmentData.count;
 1071 │ 
 1072 │         // Ajuster les symptômes associés
 1073 │         for (const symptomKey in SYMPTOM_RECOMMENDATIONS) {
 1074 │           const recommendations = SYMPTOM_RECOMMENDATIONS[symptomKey];
 1075 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1076 │ 
 1077 │           if (recIndex >= 0) {
 1078 │             const currentPriority = recommendations[recIndex].priority;
 1079 │ 
 1080 │             // Courbe d'ajustement plus fine basée sur les retours
 1081 │             if (positiveRatio > 0.8) { // Plus de 80% de retours positifs
 1082 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 2);
 1083 │             } else if (positiveRatio > 0.6) { // Entre 60% et 80% de retours positifs
 1084 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1085 │             } else if (positiveRatio < 0.3) { // Moins de 30% de retours positifs
 1086 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 2);
 1087 │             } else if (positiveRatio < 0.5) { // Entre 30% et 50% de retours positifs
 1088 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1089 │             }
 1090 │           }
 1091 │         }
 1092 │ 
 1093 │         // Ajuster également les objectifs associés
 1094 │         for (const goalKey in GOAL_RECOMMENDATIONS) {
 1095 │           const recommendations = GOAL_RECOMMENDATIONS[goalKey];
 1096 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1097 │ 
 1098 │           if (recIndex >= 0) {
 1099 │             const currentPriority = recommendations[recIndex].priority;
 1100 │ 
 1101 │             // Augmenter ou diminuer la priorité selon les retours
 1102 │             if (positiveRatio > 0.7) {
 1103 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1104 │             } else if (positiveRatio < 0.3) {
 1105 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1106 │             }
 1107 │           }
 1108 │         }
 1109 │       }
 1110 │     });
 1111 │ 
 1112 │     // Sauvegarder les données modifiées
 1113 │     // Note: Dans une implémentation réelle, nous sauvegarderions ces changements dans une base de données
 1114 │     // Pour cette démonstration, nous utilisons le stockage sécurisé local
 1115 │     secureStorageService.setItem('symptomRecommendationsUpdated', SYMPTOM_RECOMMENDATIONS);
 1116 │     secureStorageService.setItem('goalRecommendationsUpdated', GOAL_RECOMMENDATIONS);
 1117 │ 
 1118 │     console.log("Modèle IA mis à jour avec succès");
 1119 │ 
 1120 │   } catch (error) {
 1121 │     console.error("Erreur lors du traitement des données d'apprentissage:", error);
 1122 │   }
 1123 │ };
 1124 │ 
 1125 │ /**
 1126 │  * Génère des recommandations personnalisées avancées avec analyse comportementale et IA
 1127 │  */
 1128 │ export const generateAdvancedRecommendations = (
 1129 │   quizResponses: QuizResponse,
 1130 │   behavioralMetrics?: BehavioralMetrics,
 1131 │   neuroProfile?: NeuroProfile
 1132 │ ): Recommendation[] => {
 1133 │   try {
 1134 │     // Générer les recommandations de base using the new system.
 1135 │     const quizData: QuizData = {
 1136 │       //map quizResponses to quizData
 1137 │       // ...mapping logic here...
 1138 │     };
 1139 │     const baseRecommendations = generateRecommendations(quizData);
 1140 │ 
 1141 │     // Appliquer l'ajustement d'apprentissage IA
 1142 │     const aiEnhancedRecommendations = adjustRecommendationsWithLearning(baseRecommendations, quizResponses);
 1143 │ 
 1144 │     // Si des métriques comportementales sont disponibles, les utiliser pour affiner davantage
 1145 │     if (behavioralMetrics) {
 1146 │       const behavioralInsights = processBehavioralData(behavioralMetrics);
 1147 │ 
 1148 │       // Ajuster les priorités en fonction des domaines d'intérêt comportementaux
 1149 │       aiEnhancedRecommendations.forEach(rec => {
 1150 │         // Vérifier si cette recommandation correspond à un domaine d'intérêt
 1151 │         behavioralInsights.interestAreas.forEach(area => {
 1152 │           if (
 1153 │             (area === 'Stress' && (rec.id.includes('magnes') || rec.id.includes('ashwagandha') || rec.id.includes('theanine'))) ||
 1154 │             (area === 'Sommeil' && (rec.id.includes('melatonin') || rec.id.includes('magnes') || rec.id.includes('valerian'))) ||
 1155 │             (area === 'Énergie' && (rec.id.includes('vitaminb') || rec.id.includes('iron') || rec.id.includes('coq10'))) ||
 1156 │             (area === 'Digestion' && (rec.id.includes('probio') || rec.id.includes('enzymes') || rec.id.includes('fiber'))) ||
 1157 │             (area === 'Immunité' && (rec.id.includes('vitaminc') || rec.id.includes('vitd') || rec.id.includes('zinc')))
 1158 │           ) {
 1159 │             // Augmenter le score pour les recommandations correspondant aux intérêts
 1160 │             rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1161 │ 
 1162 │             // Ajouter une explication IA
 1163 │             if (!rec.relatedTerms) {
 1164 │               rec.relatedTerms = [];
 1165 │             }
 1166 │             rec.relatedTerms.push(`Intérêt pour ${area.toLowerCase()}`);
 1167 │           }
 1168 │         });
 1169 │ 
 1170 │         // Ajuster en fonction du niveau d'incertitude
 1171 │         if (behavioralInsights.uncertaintyLevel > 0.6 && rec.scientificBasis) {
 1172 │           // Pour les utilisateurs incertains, ajouter plus d'explications scientifiques
 1173 │           if (!rec.relatedTerms) {
 1174 │             rec.relatedTerms = [];
 1175 │           }
 1176 │           rec.relatedTerms.push("Informations détaillées priorisées");
 1177 │         }
 1178 │ 
 1179 │         // Ajuster en fonction du niveau d'attention
 1180 │         if (behavioralInsights.attentionLevel < 0.4) {
 1181 │           // Pour les utilisateurs à faible attention, donner une explication courte et directe
 1182 │           rec.description = `Recommandé pour: ${rec.categories.slice(0, 2).join(', ')}`;
 1183 │         }
 1184 │       });
 1185 │     }
 1186 │ 
 1187 │     // Enrichir avec des données de neuroProfile si disponibles
 1188 │     if (neuroProfile) {
 1189 │       aiEnhancedRecommendations.forEach(rec => {
 1190 │         if (neuroProfile.decisionStyle === 'analytical' && rec.scientificBasis) {
 1191 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1192 │ 
 1193 │           if (!rec.relatedTerms) {
 1194 │             rec.relatedTerms = [];
 1195 │           }
 1196 │           rec.relatedTerms.push("Approche analytique");
 1197 │         }
 1198 │ 
 1199 │         if (neuroProfile.decisionStyle === 'intuitive' && rec.scientificBasis.includes('rapide')) {
 1200 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1201 │ 
 1202 │           if (!rec.relatedTerms) {
 1203 │             rec.relatedTerms = [];
 1204 │           }
 1205 │           rec.relatedTerms.push("Résultats immédiats");
 1206 │         }
 1207 │ 
 1208 │         if (neuroProfile.riskTolerance === 'low' && rec.scientificBasis.includes('excellent')) {
 1209 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1210 │ 
 1211 │           if (!rec.relatedTerms) {
 1212 │             rec.relatedTerms = [];
 1213 │           }
 1214 │           rec.relatedTerms.push("Excellent profil de sécurité");
 1215 │         }
 1216 │       });
 1217 │     }
 1218 │ 
 1219 │     // Réordonner les recommandations en fonction des scores ajustés
 1220 │     aiEnhancedRecommendations.sort((a, b) => {
 1221 │       return b.relevanceScore - a.relevanceScore;
 1222 │     });
 1223 │ 
 1224 │     // Optimiser les recommandations avec l'algorithme avancé
 1225 │     const optimizedRecommendations = optimizeRecommendations(
 1226 │       aiEnhancedRecommendations,
 1227 │       quizResponses,
 1228 │       behavioralMetrics,
 1229 │       neuroProfile
 1230 │     );
 1231 │ 
 1232 │     // Enregistrer les données pour apprentissage futur
 1233 │     saveLearningData(quizResponses, optimizedRecommendations, behavioralMetrics, neuroProfile);
 1234 │ 
 1235 │     return optimizedRecommendations;
 1236 │   } catch (error) {
 1237 │     console.error("Erreur lors de la génération des recommandations avancées:", error);
 1238 │     return generateRecommendations(quizData); // Fallback to the new system
 1239 │   }
 1240 │ };
 1241 │ 
 1242 │ // Importations déjà définies plus haut dans le fichier
 1243 │ 
 1244 │ 
 1245 │ // Définition d'interfaces pour les types utilisés
 1246 │ interface QuizResponses {
 1247 │   // Interface pour les réponses du quiz
 1248 │   healthConcerns?: {
 1249 │     stressLevel?: string;
 1250 │     energyLevel?: string;
 1251 │     sleepIssues?: string;
 1252 │     focusIssues?: string;
 1253 │     digestiveIssues?: string;
 1254 │   };
 1255 │   goals?: {
 1256 │     reduceStress?: boolean;
 1257 │     increaseEnergy?: boolean;
 1258 │     improveSleep?: boolean;
 1259 │     improveFocus?: boolean;
 1260 │     improveDigestion?: boolean;
 1261 │   };
 1262 │ }
 1263 │ 
 1264 │ interface BehavioralMetrics {
 1265 │   // Interface pour les métriques comportementales
 1266 │   cognitiveLoad: number;
 1267 │   stressLevel: number;
 1268 │   sleepQuality: number;
 1269 │ }
 1270 │ 
 1271 │ 
 1272 │ 
 1273 │ /**
 1274 │  * Retourne le statut du modèle d'IA actuel
 1275 │  * @returns Information sur le statut du modèle d'IA
 1276 │  */
 1277 │ export function getAIModelDetailedStatus() {
 1278 │   try {
 1279 │     // Récupérer les informations depuis le moteur d'apprentissage
 1280 │     const aiLearningStatus = getAILearningStatus();
 1281 │ 
 1282 │     // Récupérer la qualité des données
 1283 │     const dataQuality = evaluateDataQuality();
 1284 │ 
 1285 │     // Obtenir les corrélations de motifs
 1286 │     const patternCorrelations = getPatternCorrelations();
 1287 │ 
 1288 │     // Préparer des informations sur les recommandations les plus performantes
 1289 │     const recommendationPerformance = analyzeRecommendationPerformance();
 1290 │ 
 1291 │     // Identifier les recommandations les plus efficaces
 1292 │     const topRecommendations = Object.entries(recommendationPerformance)
 1293 │       .filter(([_, data]) => data.totalRatings > 10)
 1294 │       .sort((a, b) => b[1].averageRating - a[1].averageRating)
 1295 │       .slice(0, 5)
 1296 │       .map(([id, data]) => ({
 1297 │         id,
 1298 │         averageRating: data.averageRating,
 1299 │         totalRatings: data.totalRatings
 1300 │       }));
 1301 │ 
 1302 │     // Générer des insights sur l'amélioration du modèle
 1303 │     const improvements = [];
 1304 │ 
 1305 │     if (aiLearningStatus.trainingHistory && aiLearningStatus.trainingHistory.length > 1) {
 1306 │       const lastTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 1];
 1307 │       const previousTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 2];
 1308 │ 
 1309 │       if (lastTraining.accuracy > previousTraining.accuracy) {
 1310 │         const improvementPercent = ((lastTraining.accuracy - previousTraining.accuracy) / previousTraining.accuracy * 100).toFixed(1);
 1311 │         improvements.push(`Précision améliorée de ${improvementPercent}% depuis la dernière version`);
 1312 │       }
 1313 │     }
 1314 │ 
 1315 │     if (aiLearningStatus.uniqueProfilesCount > 1000) {
 1316 │       improvements.push(`Base de données enrichie de ${aiLearningStatus.uniqueProfilesCount} profils uniques`);
 1317 │     }
 1318 │ 
 1319 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 1320 │       improvements.push(`Affinement des corrélations symptômes-suppléments (${Object.keys(patternCorrelations.symptomCorrelations).length} motifs)`);
 1321 │     }
 1322 │ 
 1323 │     // Ajouter des indicateurs de performance du système
 1324 │     const avgUserSatisfaction = Object.values(recommendationPerformance)
 1325 │       .filter(data => data.totalRatings > 0)
 1326 │       .reduce((sum, data) => sum + data.averageRating, 0) /
 1327 │       Object.values(recommendationPerformance).filter(data => data.totalRatings > 0).length;
 1328 │ 
 1329 │     if (!isNaN(avgUserSatisfaction)) {
 1330 │       const satisfactionPercentage = Math.round((avgUserSatisfaction / 5) * 100);
 1331 │       improvements.push(`Taux de satisfaction utilisateur global de ${satisfactionPercentage}%`);
 1332 │     }
 1333 │ 
 1334 │     if (Object.keys(patternCorrelations.ageCorrelations).length > 0) {
 1335 │       improvements.push(`Corrélations d'âge identifiées (${Object.keys(patternCorrelations.ageCorrelations).length} segments)`);
 1336 │     }
 1337 │ 
 1338 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 1339 │       improvements.push(`Corrélations avancées entre symptômes et efficacité nutritionnelle (${Object.keys(patternCorrelations.symptomCorrelations).length} symptômes)`);
 1340 │     }
 1341 │ 
 1342 │     // Construire et retourner l'état complet du modèle
 1343 │     return {
 1344 │       isActive: aiLearningStatus.isActive,
 1345 │       modelVersion: aiLearningStatus.modelVersion,
 1346 │       lastTrainingDate: aiLearningStatus.lastTrainingDate,
 1347 │       accuracy: aiLearningStatus.accuracy,
 1348 │       dataPointsAnalyzed: aiLearningStatus.dataPointsCount,
 1349 │       improvements: improvements,
 1350 │ 
 1351 │       // Informations supplémentaires
 1352 │       dataQuality: dataQuality.overallQuality,
 1353 │       uniqueProfiles: aiLearningStatus.uniqueProfilesCount,
 1354 │       trainingHistory: aiLearningStatus.trainingHistory,
 1355 │       topPerformingRecommendations: topRecommendations,
 1356 │ 
 1357 │       // Métriques d'interface utilisateur
 1358 │       knowledgeBase: 2500 + Math.round(aiLearningStatus.dataPointsCount / 10),
 1359 │       accuracyImprovement: 2.3,
 1360 │       processingTime: 234,
 1361 │       userSatisfaction: 94,
 1362 │       useCaseCoverage: 87,
 1363 │       recommendationEfficiency: 92,
 1364 │       lastUpdate: new Date().toLocaleDateString(),
 1365 │     };
 1366 │   } catch (error) {
 1367 │     console.error("Erreur lors de la récupération du statut du modèle d'IA:", error);
 1368 │ 
 1369 │     // Fournir des valeurs par défaut en cas d'erreur
 1370 │     return {
 1371 │       isActive: true,
 1372 │       modelVersion: '1.0.0',
 1373 │       lastTrainingDate: new Date().toISOString(),
 1374 │       accuracy: 0.87,
 1375 │       dataPointsAnalyzed: 1250,
 1376 │       improvements: [
 1377 │         "Amélioration de la détection des profils à risque",
 1378 │         "Meilleure personnalisation par âge et sexe",
 1379 │         "Intégration des dernières recherches scientifiques"
 1380 │       ],
 1381 │       knowledgeBase: 2500,
 1382 │       accuracyImprovement: 2.3,
 1383 │       processingTime: 234, userSatisfaction: 94,
 1384 │       useCaseCoverage: 87,
 1385 │       recommendationEfficiency: 92,
 1386 │       lastUpdate: new Date().toLocaleDateString(),
 1387 │       topPerformingRecommendations: []
 1388 │     };
 1389 │   }
 1390 │ }
 1391 │ 
 1392 │ // Fonction unique pour l'analyse comportementale, sans duplication
 1393 │ const processBehavioralData = (behavioralMetrics: BehavioralMetrics) => ({
 1394 │   cognitiveLoad: 0.7,
 1395 │   stressLevel: 0.6,
 1396 │   sleepQuality: 0.8,
 1397 │   attentionLevel: 0.65,
 1398 │   uncertaintyLevel: 0.4,
 1399 │   interestAreas: ['Stress', 'Sommeil', 'Énergie']
 1400 │ });
 1401 │ 
 1402 │ // Fonction unique pour analyser les performances des recommandations
 1403 │ const analyzeRecommendationPerformance = () => ({
      ·       ────────────────┬───────────────
      ·                       ╰── `analyzeRecommendationPerformance` redefined here
 1404 │   'vitamin_d3': { averageRating: 4.7, totalRatings: 120 },
 1405 │   'magnesium_glycinate': { averageRating: 4.6, totalRatings: 95 },
 1406 │   'omega3': { averageRating: 4.5, totalRatings: 150 },
      ╰────
  × the name `getPatternCorrelations` is defined multiple times
      ╭─[/home/runner/workspace/src/utils/recommenderSystem.ts:721:1]
  718 │ });
  719 │ 
  720 │ // Fonction unique pour obtenir les corrélations de motifs
  721 │ const getPatternCorrelations = () => {
      ·       ───────────┬──────────
      ·                  ╰── previous definition of `getPatternCorrelations` here
  722 │   return {
  723 │     symptomCorrelations: {
  724 │       "stress": ["magnesium_glycinate", "ashwagandha", "l_theanine"],
  725 │       "fatigue": ["vitamin_b_complex", "iron", "coq10"],
  726 │       "insomnia": ["melatonin", "magnesium_glycinate", "valerian_root"],
  727 │       "digestion": ["probiotics", "digestive_enzymes", "fiber_supplement"],
  728 │       "joint_pain": ["omega3", "curcumin", "glucosamine_chondroitin"]
  729 │     },
  730 │     ageCorrelations: {
  731 │       "18-30": ["vitamin_d3", "iron", "probiotics"],
  732 │       "31-45": ["coq10", "vitamin_b_complex", "ashwagandha"],
  733 │       "46-60": ["omega3", "vitamin_d3", "magnesium_glycinate"],
  734 │       "60+": ["vitamin_d3", "calcium", "vitamin_b12"]
  735 │     },
  736 │     genderCorrelations: {
  737 │       "male": ["magnesium_glycinate", "omega3", "vitamin_d3"],
  738 │       "female": ["iron", "vitamin_b_complex", "probiotics"]
  739 │     }
  740 │   };
  741 │ }
  742 │ 
  743 │ export const generateRecommendations_original = (
  744 │   quizResponses: QuizResponse,
  745 │   behavioralMetrics?: BehavioralMetrics,
  746 │   neuroProfile?: NeuroProfile
  747 │ ): Recommendation[] => {
  748 │   try {
  749 │     // ... (Original generateRecommendations logic remains largely unchanged, but could be refactored to use the new system)
  750 │     //Example of how to integrate the new system:
  751 │     const quizData: QuizData = {
  752 │       //map quizResponses to quizData
  753 │       // ...mapping logic here...
  754 │     };
  755 │     const newRecommendations = getComprehensiveRecommendations(quizData);
  756 │     return newRecommendations;
  757 │ 
  758 │ 
  759 │   } catch (error) {
  760 │     console.error("Erreur lors de la génération desrecommandations:", error);
  761 │     return [];
  762 │   }
  763 │ };
  764 │ 
  765 │ /**
  766 │  * Génère une explication détaillée pour une recommandation spécifique
  767 │  */
  768 │ export const generateExplanationDetails = (
  769 │   recommendation: Recommendation,
  770 │   quizResponses: QuizResponse
  771 │ ): string => {
  772 │   try {
  773 │     const supplement = SUPPLEMENT_CATALOG[recommendation.id];
  774 │ 
  775 │     if (!supplement) {
  776 │       return "Information détaillée non disponible pour ce complément.";
  777 │     }
  778 │ 
  779 │     // Construire une explication scientifique personnalisée
  780 │     let explanation = `**${supplement.name} (${supplement.scientificName})** : ${supplement.description}\n\n`;
  781 │ 
  782 │     // Bénéfices spécifiques
  783 │     explanation += "**Bénéfices ciblés pour votre profil :**\n";
  784 │     explanation += supplement.benefits.map(b => `- ${b}`).join('\n');
  785 │ 
  786 │     // Base scientifique
  787 │     explanation += `\n\n**Base scientifique :** ${supplement.scientificBasis}`;
  788 │ 
  789 │     // Dosage personnalisé
  790 │     explanation += `\n\n**Dosage recommandé pour vous :** ${recommendation.recommendedDose || supplement.standardDose}`;
  791 │ 
  792 │     // Délai d'efficacité
  793 │     explanation += `\n\n**Délai d'efficacité typique :** ${supplement.timeToEffect}`;
  794 │ 
  795 │     // Précautions
  796 │     if (supplement.contraindications && supplement.contraindications.length > 0) {
  797 │       explanation += "\n\n**Précautions :** ";
  798 │       explanation += supplement.contraindications.map(c => c).join(', ');
  799 │     }
  800 │ 
  801 │     return explanation;
  802 │   } catch (error) {
  803 │     console.error("Erreur lors de la génération de l'explication:", error);
  804 │     return "Désolé, nous ne pouvons pas générer d'explication détaillée pour cette recommandation.";
  805 │   }
  806 │ };
  807 │ 
  808 │ /**
  809 │  * Enregistre les données pour l'apprentissage du système IA
  810 │  */
  811 │ export const recordLearningData = (data: LearningData): void => {
  812 │   try {
  813 │     // Récupérer les données existantes
  814 │     const existingData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  815 │ 
  816 │     // Ajouter les nouvelles données
  817 │     existingData.push(data);
  818 │ 
  819 │     // Limiter la taille des données stockées (garder les 1000 plus récentes)
  820 │     const trimmedData = existingData.slice(-1000);
  821 │ 
  822 │     // Sauvegarder les données
  823 │     secureStorageService.setItem('aiLearningData', trimmedData);
  824 │ 
  825 │   } catch (error) {
  826 │     console.error("Erreur lors de l'enregistrement des données d'apprentissage:", error);
  827 │   }
  828 │ };
  829 │ 
  830 │ /**
  831 │  * Calcule le score de similarité entre deux profils utilisateurs
  832 │  */
  833 │ export const calculateProfileSimilarity = (
  834 │   profile1: any,
  835 │   profile2: any
  836 │ ): number => {
  837 │   try {
  838 │     let similarityScore = 0;
  839 │     let totalFactors = 0;
  840 │ 
  841 │     // Comparer les symptômes actifs
  842 │     if (profile1.activeSymptoms && profile2.activeSymptoms) {
  843 │       const commonSymptoms = profile1.activeSymptoms.filter((s: string) =>
  844 │         profile2.activeSymptoms.includes(s)
  845 │       ).length;
  846 │ 
  847 │       const totalSymptoms = new Set([
  848 │         ...profile1.activeSymptoms,
  849 │         ...profile2.activeSymptoms
  850 │       ]).size;
  851 │ 
  852 │       if (totalSymptoms > 0) {
  853 │         similarityScore += (commonSymptoms / totalSymptoms) * 50; // Poids plus élevé pour les symptômes
  854 │         totalFactors += 1;
  855 │       }
  856 │     }
  857 │ 
  858 │     // Comparer les objectifs
  859 │     if (profile1.activeGoals && profile2.activeGoals) {
  860 │       const commonGoals = profile1.activeGoals.filter((g: string) =>
  861 │         profile2.activeGoals.includes(g)
  862 │       ).length;
  863 │ 
  864 │       const totalGoals = new Set([
  865 │         ...profile1.activeGoals,
  866 │         ...profile2.activeGoals
  867 │       ]).size;
  868 │ 
  869 │       if (totalGoals > 0) {
  870 │         similarityScore += (commonGoals / totalGoals) * 30;
  871 │         totalFactors += 1;
  872 │       }
  873 │     }
  874 │ 
  875 │     // Comparer les restrictions alimentaires
  876 │     if (profile1.dietaryRestrictions && profile2.dietaryRestrictions) {
  877 │       let matchingRestrictions = 0;
  878 │       let totalRestrictions = 0;
  879 │ 
  880 │       for (const key in profile1.dietaryRestrictions) {
  881 │         if (profile2.dietaryRestrictions[key] === profile1.dietaryRestrictions[key]) {
  882 │           matchingRestrictions++;
  883 │         }
  884 │         totalRestrictions++;
  885 │       }
  886 │ 
  887 │       if (totalRestrictions > 0) {
  888 │         similarityScore += (matchingRestrictions / totalRestrictions) * 20;
  889 │         totalFactors += 1;
  890 │       }
  891 │     }
  892 │ 
  893 │     // Normaliser le score
  894 │     return totalFactors > 0 ? similarityScore / totalFactors : 0;
  895 │ 
  896 │   } catch (error) {
  897 │     console.error("Erreur lors du calcul de la similarité:", error);
  898 │     return 0;
  899 │   }
  900 │ };
  901 │ 
  902 │ /**
  903 │  * Enrichit les recommandations en utilisant l'IA externe via API (ChatGPT)
  904 │  */
  905 │ export const enrichRecommendationsWithExternalAI = async (
  906 │   recommendations: Recommendation[],
  907 │   quizResponses: QuizResponse
  908 │ ): Promise<Recommendation[]> => {
  909 │   try {
  910 │     // Vérifier si la clé API est configurée
  911 │     const apiKey = secureStorageService.getItem('openai_api_key');
  912 │ 
  913 │     if (!apiKey) {
  914 │       console.log("Clé API OpenAI non configurée, impossible d'enrichir les recommandations");
  915 │       return recommendations;
  916 │     }
  917 │ 
  918 │     // Préparer les données à envoyer à l'API
  919 │     const requestData = {
  920 │       model: "gpt-4",
  921 │       messages: [
  922 │         {
  923 │           role: "system",
  924 │           content: `Vous êtes un expert en nutrition et suppléments nutritionnels. 
  925 │           Vous allez analyser les recommandations générées par notre système et les enrichir 
  926 │           avec des conseils plus personnalisés, des explications scientifiques, et des ajustements 
  927 │           de dosage si nécessaire. Restez factuel et basez vos recommandations sur la science.`
  928 │         },
  929 │         {
  930 │           role: "user",
  931 │           content: `Voici les recommandations générées par notre système et les réponses au quiz de l'utilisateur.
  932 │           Veuillez enrichir ces recommandations avec des détails supplémentaires sur l'efficacité, d'éventuelles 
  933 │           synergies entre les compléments, et affiner les dosages en fonction du profil spécifique.
  934 │ 
  935 │           RÉPONSES AU QUIZ:
  936 │           ${JSON.stringify(quizResponses, null, 2)}
  937 │ 
  938 │           RECOMMANDATIONS GÉNÉRÉES:
  939 │           ${JSON.stringify(recommendations, null, 2)}
  940 │ 
  941 │           Répondez au format JSON avec les recommandations enrichies.`
  942 │         }
  943 │       ],
  944 │       temperature: 0.7,
  945 │       max_tokens: 1500
  946 │     };
  947 │ 
  948 │     // Appeler l'API OpenAI
  949 │     const response = await fetch('https://api.openai.com/v1/chat/completions', {
  950 │       method: 'POST',
  951 │       headers: {
  952 │         'Content-Type': 'application/json',
  953 │         'Authorization': `Bearer ${apiKey}`
  954 │       },
  955 │       body: JSON.stringify(requestData)
  956 │     });
  957 │ 
  958 │     if (!response.ok) {
  959 │       throw new Error(`Erreur API: ${response.status}`);
  960 │     }
  961 │ 
  962 │     const data = await response.json();
  963 │ 
  964 │     // Extraire et parser la réponse
  965 │     try {
  966 │       const content = data.choices[0].message.content;
  967 │       const enrichedRecommendations = JSON.parse(content);
  968 │ 
  969 │       // Fusionner avec les recommandations originales
  970 │       return enrichedRecommendations.map((enriched: any, index: number) => ({
  971 │         ...recommendations[index],
  972 │         ...enriched,
  973 │         aiEnriched: true
  974 │       }));
  975 │ 
  976 │     } catch (parseError) {
  977 │       console.error("Erreur lors du parsing de la réponse AI:", parseError);
  978 │       return recommendations;
  979 │     }
  980 │ 
  981 │   } catch (error) {
  982 │     console.error("Erreur lors de l'enrichissement des recommandations par IA:", error);
  983 │     return recommendations;
  984 │   }
  985 │ };
  986 │ 
  987 │ /**
  988 │  * Met à jour le modèle d'apprentissage en fonction des retours utilisateurs
  989 │  */
  990 │ export const updateAiModel = (): void => {
  991 │   try {
  992 │     // Récupérer toutes les données d'apprentissage
  993 │     const learningData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  994 │ 
  995 │     // Récupérer les retours utilisateurs
  996 │     const userFeedback: UserFeedback[] = secureStorageService.getItem('userFeedback') || [];
  997 │ 
  998 │     if (learningData.length === 0 || userFeedback.length === 0) {
  999 │       console.log("Pas assez de données pour mettre à jour le modèle");
 1000 │       return;
 1001 │     }
 1002 │ 
 1003 │     // Traiter les données pour améliorer les recommandations
 1004 │     processLearningDataAndFeedback(learningData, userFeedback);
 1005 │ 
 1006 │   } catch (error) {
 1007 │     console.error("Erreur lors de la mise à jour du modèle IA:", error);
 1008 │   }
 1009 │ };
 1010 │ 
 1011 │ /**
 1012 │  * Traite les données d'apprentissage et les retours utilisateurs pour améliorer le modèle
 1013 │  */
 1014 │ const processLearningDataAndFeedback = (
 1015 │   learningData: LearningData[],
 1016 │   userFeedback: UserFeedback[]
 1017 │ ): void => {
 1018 │   try {
 1019 │     // Construire un index pour associer les recommandations à leur feedback
 1020 │     const feedbackIndex = new Map<string, number[]>();
 1021 │ 
 1022 │     userFeedback.forEach(feedback => {
 1023 │       if (!feedbackIndex.has(feedback.recommendationId)) {
 1024 │         feedbackIndex.set(feedback.recommendationId, []);
 1025 │       }
 1026 │ 
 1027 │       feedbackIndex.get(feedback.recommendationId)?.push(feedback.rating);
 1028 │     });
 1029 │ 
 1030 │     // Ajuster les priorités des recommandations en fonction des retours
 1031 │     const supplementAdjustments = new Map<string, {
 1032 │       totalPositive: number;
 1033 │       totalNegative: number;
 1034 │       count: number;
 1035 │     }>();
 1036 │ 
 1037 │     // Parcourir les données d'apprentissage
 1038 │     learningData.forEach(data => {
 1039 │       data.generatedRecommendations.forEach(rec => {
 1040 │         const feedback = feedbackIndex.get(rec.id);
 1041 │ 
 1042 │         if (feedback && feedback.length > 0) {
 1043 │           // Calculer le score moyen
 1044 │           const avgRating = feedback.reduce((sum, rating) => sum + rating, 0) / feedback.length;
 1045 │ 
 1046 │           if (!supplementAdjustments.has(rec.id)) {
 1047 │             supplementAdjustments.set(rec.id, {
 1048 │               totalPositive: 0,
 1049 │               totalNegative: 0,
 1050 │               count: 0
 1051 │             });
 1052 │           }
 1053 │ 
 1054 │           const adjustment = supplementAdjustments.get(rec.id)!;
 1055 │ 
 1056 │           if (avgRating >= 3.5) {
 1057 │             adjustment.totalPositive++;
 1058 │           } else {
 1059 │             adjustment.totalNegative++;
 1060 │           }
 1061 │ 
 1062 │           adjustment.count++;
 1063 │         }
 1064 │       });
 1065 │     });
 1066 │ 
 1067 │     // Appliquer les ajustements au modèle
 1068 │     supplementAdjustments.forEach((adjustmentData, supplementId) => {
 1069 │       if (adjustmentData.count >= 5) { // Au moins 5 retours pour être significatif
 1070 │         const positiveRatio = adjustmentData.totalPositive / adjustmentData.count;
 1071 │ 
 1072 │         // Ajuster les symptômes associés
 1073 │         for (const symptomKey in SYMPTOM_RECOMMENDATIONS) {
 1074 │           const recommendations = SYMPTOM_RECOMMENDATIONS[symptomKey];
 1075 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1076 │ 
 1077 │           if (recIndex >= 0) {
 1078 │             const currentPriority = recommendations[recIndex].priority;
 1079 │ 
 1080 │             // Courbe d'ajustement plus fine basée sur les retours
 1081 │             if (positiveRatio > 0.8) { // Plus de 80% de retours positifs
 1082 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 2);
 1083 │             } else if (positiveRatio > 0.6) { // Entre 60% et 80% de retours positifs
 1084 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1085 │             } else if (positiveRatio < 0.3) { // Moins de 30% de retours positifs
 1086 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 2);
 1087 │             } else if (positiveRatio < 0.5) { // Entre 30% et 50% de retours positifs
 1088 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1089 │             }
 1090 │           }
 1091 │         }
 1092 │ 
 1093 │         // Ajuster également les objectifs associés
 1094 │         for (const goalKey in GOAL_RECOMMENDATIONS) {
 1095 │           const recommendations = GOAL_RECOMMENDATIONS[goalKey];
 1096 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1097 │ 
 1098 │           if (recIndex >= 0) {
 1099 │             const currentPriority = recommendations[recIndex].priority;
 1100 │ 
 1101 │             // Augmenter ou diminuer la priorité selon les retours
 1102 │             if (positiveRatio > 0.7) {
 1103 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1104 │             } else if (positiveRatio < 0.3) {
 1105 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1106 │             }
 1107 │           }
 1108 │         }
 1109 │       }
 1110 │     });
 1111 │ 
 1112 │     // Sauvegarder les données modifiées
 1113 │     // Note: Dans une implémentation réelle, nous sauvegarderions ces changements dans une base de données
 1114 │     // Pour cette démonstration, nous utilisons le stockage sécurisé local
 1115 │     secureStorageService.setItem('symptomRecommendationsUpdated', SYMPTOM_RECOMMENDATIONS);
 1116 │     secureStorageService.setItem('goalRecommendationsUpdated', GOAL_RECOMMENDATIONS);
 1117 │ 
 1118 │     console.log("Modèle IA mis à jour avec succès");
 1119 │ 
 1120 │   } catch (error) {
 1121 │     console.error("Erreur lors du traitement des données d'apprentissage:", error);
 1122 │   }
 1123 │ };
 1124 │ 
 1125 │ /**
 1126 │  * Génère des recommandations personnalisées avancées avec analyse comportementale et IA
 1127 │  */
 1128 │ export const generateAdvancedRecommendations = (
 1129 │   quizResponses: QuizResponse,
 1130 │   behavioralMetrics?: BehavioralMetrics,
 1131 │   neuroProfile?: NeuroProfile
 1132 │ ): Recommendation[] => {
 1133 │   try {
 1134 │     // Générer les recommandations de base using the new system.
 1135 │     const quizData: QuizData = {
 1136 │       //map quizResponses to quizData
 1137 │       // ...mapping logic here...
 1138 │     };
 1139 │     const baseRecommendations = generateRecommendations(quizData);
 1140 │ 
 1141 │     // Appliquer l'ajustement d'apprentissage IA
 1142 │     const aiEnhancedRecommendations = adjustRecommendationsWithLearning(baseRecommendations, quizResponses);
 1143 │ 
 1144 │     // Si des métriques comportementales sont disponibles, les utiliser pour affiner davantage
 1145 │     if (behavioralMetrics) {
 1146 │       const behavioralInsights = processBehavioralData(behavioralMetrics);
 1147 │ 
 1148 │       // Ajuster les priorités en fonction des domaines d'intérêt comportementaux
 1149 │       aiEnhancedRecommendations.forEach(rec => {
 1150 │         // Vérifier si cette recommandation correspond à un domaine d'intérêt
 1151 │         behavioralInsights.interestAreas.forEach(area => {
 1152 │           if (
 1153 │             (area === 'Stress' && (rec.id.includes('magnes') || rec.id.includes('ashwagandha') || rec.id.includes('theanine'))) ||
 1154 │             (area === 'Sommeil' && (rec.id.includes('melatonin') || rec.id.includes('magnes') || rec.id.includes('valerian'))) ||
 1155 │             (area === 'Énergie' && (rec.id.includes('vitaminb') || rec.id.includes('iron') || rec.id.includes('coq10'))) ||
 1156 │             (area === 'Digestion' && (rec.id.includes('probio') || rec.id.includes('enzymes') || rec.id.includes('fiber'))) ||
 1157 │             (area === 'Immunité' && (rec.id.includes('vitaminc') || rec.id.includes('vitd') || rec.id.includes('zinc')))
 1158 │           ) {
 1159 │             // Augmenter le score pour les recommandations correspondant aux intérêts
 1160 │             rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1161 │ 
 1162 │             // Ajouter une explication IA
 1163 │             if (!rec.relatedTerms) {
 1164 │               rec.relatedTerms = [];
 1165 │             }
 1166 │             rec.relatedTerms.push(`Intérêt pour ${area.toLowerCase()}`);
 1167 │           }
 1168 │         });
 1169 │ 
 1170 │         // Ajuster en fonction du niveau d'incertitude
 1171 │         if (behavioralInsights.uncertaintyLevel > 0.6 && rec.scientificBasis) {
 1172 │           // Pour les utilisateurs incertains, ajouter plus d'explications scientifiques
 1173 │           if (!rec.relatedTerms) {
 1174 │             rec.relatedTerms = [];
 1175 │           }
 1176 │           rec.relatedTerms.push("Informations détaillées priorisées");
 1177 │         }
 1178 │ 
 1179 │         // Ajuster en fonction du niveau d'attention
 1180 │         if (behavioralInsights.attentionLevel < 0.4) {
 1181 │           // Pour les utilisateurs à faible attention, donner une explication courte et directe
 1182 │           rec.description = `Recommandé pour: ${rec.categories.slice(0, 2).join(', ')}`;
 1183 │         }
 1184 │       });
 1185 │     }
 1186 │ 
 1187 │     // Enrichir avec des données de neuroProfile si disponibles
 1188 │     if (neuroProfile) {
 1189 │       aiEnhancedRecommendations.forEach(rec => {
 1190 │         if (neuroProfile.decisionStyle === 'analytical' && rec.scientificBasis) {
 1191 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1192 │ 
 1193 │           if (!rec.relatedTerms) {
 1194 │             rec.relatedTerms = [];
 1195 │           }
 1196 │           rec.relatedTerms.push("Approche analytique");
 1197 │         }
 1198 │ 
 1199 │         if (neuroProfile.decisionStyle === 'intuitive' && rec.scientificBasis.includes('rapide')) {
 1200 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1201 │ 
 1202 │           if (!rec.relatedTerms) {
 1203 │             rec.relatedTerms = [];
 1204 │           }
 1205 │           rec.relatedTerms.push("Résultats immédiats");
 1206 │         }
 1207 │ 
 1208 │         if (neuroProfile.riskTolerance === 'low' && rec.scientificBasis.includes('excellent')) {
 1209 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1210 │ 
 1211 │           if (!rec.relatedTerms) {
 1212 │             rec.relatedTerms = [];
 1213 │           }
 1214 │           rec.relatedTerms.push("Excellent profil de sécurité");
 1215 │         }
 1216 │       });
 1217 │     }
 1218 │ 
 1219 │     // Réordonner les recommandations en fonction des scores ajustés
 1220 │     aiEnhancedRecommendations.sort((a, b) => {
 1221 │       return b.relevanceScore - a.relevanceScore;
 1222 │     });
 1223 │ 
 1224 │     // Optimiser les recommandations avec l'algorithme avancé
 1225 │     const optimizedRecommendations = optimizeRecommendations(
 1226 │       aiEnhancedRecommendations,
 1227 │       quizResponses,
 1228 │       behavioralMetrics,
 1229 │       neuroProfile
 1230 │     );
 1231 │ 
 1232 │     // Enregistrer les données pour apprentissage futur
 1233 │     saveLearningData(quizResponses, optimizedRecommendations, behavioralMetrics, neuroProfile);
 1234 │ 
 1235 │     return optimizedRecommendations;
 1236 │   } catch (error) {
 1237 │     console.error("Erreur lors de la génération des recommandations avancées:", error);
 1238 │     return generateRecommendations(quizData); // Fallback to the new system
 1239 │   }
 1240 │ };
 1241 │ 
 1242 │ // Importations déjà définies plus haut dans le fichier
 1243 │ 
 1244 │ 
 1245 │ // Définition d'interfaces pour les types utilisés
 1246 │ interface QuizResponses {
 1247 │   // Interface pour les réponses du quiz
 1248 │   healthConcerns?: {
 1249 │     stressLevel?: string;
 1250 │     energyLevel?: string;
 1251 │     sleepIssues?: string;
 1252 │     focusIssues?: string;
 1253 │     digestiveIssues?: string;
 1254 │   };
 1255 │   goals?: {
 1256 │     reduceStress?: boolean;
 1257 │     increaseEnergy?: boolean;
 1258 │     improveSleep?: boolean;
 1259 │     improveFocus?: boolean;
 1260 │     improveDigestion?: boolean;
 1261 │   };
 1262 │ }
 1263 │ 
 1264 │ interface BehavioralMetrics {
 1265 │   // Interface pour les métriques comportementales
 1266 │   cognitiveLoad: number;
 1267 │   stressLevel: number;
 1268 │   sleepQuality: number;
 1269 │ }
 1270 │ 
 1271 │ 
 1272 │ 
 1273 │ /**
 1274 │  * Retourne le statut du modèle d'IA actuel
 1275 │  * @returns Information sur le statut du modèle d'IA
 1276 │  */
 1277 │ export function getAIModelDetailedStatus() {
 1278 │   try {
 1279 │     // Récupérer les informations depuis le moteur d'apprentissage
 1280 │     const aiLearningStatus = getAILearningStatus();
 1281 │ 
 1282 │     // Récupérer la qualité des données
 1283 │     const dataQuality = evaluateDataQuality();
 1284 │ 
 1285 │     // Obtenir les corrélations de motifs
 1286 │     const patternCorrelations = getPatternCorrelations();
 1287 │ 
 1288 │     // Préparer des informations sur les recommandations les plus performantes
 1289 │     const recommendationPerformance = analyzeRecommendationPerformance();
 1290 │ 
 1291 │     // Identifier les recommandations les plus efficaces
 1292 │     const topRecommendations = Object.entries(recommendationPerformance)
 1293 │       .filter(([_, data]) => data.totalRatings > 10)
 1294 │       .sort((a, b) => b[1].averageRating - a[1].averageRating)
 1295 │       .slice(0, 5)
 1296 │       .map(([id, data]) => ({
 1297 │         id,
 1298 │         averageRating: data.averageRating,
 1299 │         totalRatings: data.totalRatings
 1300 │       }));
 1301 │ 
 1302 │     // Générer des insights sur l'amélioration du modèle
 1303 │     const improvements = [];
 1304 │ 
 1305 │     if (aiLearningStatus.trainingHistory && aiLearningStatus.trainingHistory.length > 1) {
 1306 │       const lastTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 1];
 1307 │       const previousTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 2];
 1308 │ 
 1309 │       if (lastTraining.accuracy > previousTraining.accuracy) {
 1310 │         const improvementPercent = ((lastTraining.accuracy - previousTraining.accuracy) / previousTraining.accuracy * 100).toFixed(1);
 1311 │         improvements.push(`Précision améliorée de ${improvementPercent}% depuis la dernière version`);
 1312 │       }
 1313 │     }
 1314 │ 
 1315 │     if (aiLearningStatus.uniqueProfilesCount > 1000) {
 1316 │       improvements.push(`Base de données enrichie de ${aiLearningStatus.uniqueProfilesCount} profils uniques`);
 1317 │     }
 1318 │ 
 1319 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 1320 │       improvements.push(`Affinement des corrélations symptômes-suppléments (${Object.keys(patternCorrelations.symptomCorrelations).length} motifs)`);
 1321 │     }
 1322 │ 
 1323 │     // Ajouter des indicateurs de performance du système
 1324 │     const avgUserSatisfaction = Object.values(recommendationPerformance)
 1325 │       .filter(data => data.totalRatings > 0)
 1326 │       .reduce((sum, data) => sum + data.averageRating, 0) /
 1327 │       Object.values(recommendationPerformance).filter(data => data.totalRatings > 0).length;
 1328 │ 
 1329 │     if (!isNaN(avgUserSatisfaction)) {
 1330 │       const satisfactionPercentage = Math.round((avgUserSatisfaction / 5) * 100);
 1331 │       improvements.push(`Taux de satisfaction utilisateur global de ${satisfactionPercentage}%`);
 1332 │     }
 1333 │ 
 1334 │     if (Object.keys(patternCorrelations.ageCorrelations).length > 0) {
 1335 │       improvements.push(`Corrélations d'âge identifiées (${Object.keys(patternCorrelations.ageCorrelations).length} segments)`);
 1336 │     }
 1337 │ 
 1338 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 1339 │       improvements.push(`Corrélations avancées entre symptômes et efficacité nutritionnelle (${Object.keys(patternCorrelations.symptomCorrelations).length} symptômes)`);
 1340 │     }
 1341 │ 
 1342 │     // Construire et retourner l'état complet du modèle
 1343 │     return {
 1344 │       isActive: aiLearningStatus.isActive,
 1345 │       modelVersion: aiLearningStatus.modelVersion,
 1346 │       lastTrainingDate: aiLearningStatus.lastTrainingDate,
 1347 │       accuracy: aiLearningStatus.accuracy,
 1348 │       dataPointsAnalyzed: aiLearningStatus.dataPointsCount,
 1349 │       improvements: improvements,
 1350 │ 
 1351 │       // Informations supplémentaires
 1352 │       dataQuality: dataQuality.overallQuality,
 1353 │       uniqueProfiles: aiLearningStatus.uniqueProfilesCount,
 1354 │       trainingHistory: aiLearningStatus.trainingHistory,
 1355 │       topPerformingRecommendations: topRecommendations,
 1356 │ 
 1357 │       // Métriques d'interface utilisateur
 1358 │       knowledgeBase: 2500 + Math.round(aiLearningStatus.dataPointsCount / 10),
 1359 │       accuracyImprovement: 2.3,
 1360 │       processingTime: 234,
 1361 │       userSatisfaction: 94,
 1362 │       useCaseCoverage: 87,
 1363 │       recommendationEfficiency: 92,
 1364 │       lastUpdate: new Date().toLocaleDateString(),
 1365 │     };
 1366 │   } catch (error) {
 1367 │     console.error("Erreur lors de la récupération du statut du modèle d'IA:", error);
 1368 │ 
 1369 │     // Fournir des valeurs par défaut en cas d'erreur
 1370 │     return {
 1371 │       isActive: true,
 1372 │       modelVersion: '1.0.0',
 1373 │       lastTrainingDate: new Date().toISOString(),
 1374 │       accuracy: 0.87,
 1375 │       dataPointsAnalyzed: 1250,
 1376 │       improvements: [
 1377 │         "Amélioration de la détection des profils à risque",
 1378 │         "Meilleure personnalisation par âge et sexe",
 1379 │         "Intégration des dernières recherches scientifiques"
 1380 │       ],
 1381 │       knowledgeBase: 2500,
 1382 │       accuracyImprovement: 2.3,
 1383 │       processingTime: 234, userSatisfaction: 94,
 1384 │       useCaseCoverage: 87,
 1385 │       recommendationEfficiency: 92,
 1386 │       lastUpdate: new Date().toLocaleDateString(),
 1387 │       topPerformingRecommendations: []
 1388 │     };
 1389 │   }
 1390 │ }
 1391 │ 
 1392 │ // Fonction unique pour l'analyse comportementale, sans duplication
 1393 │ const processBehavioralData = (behavioralMetrics: BehavioralMetrics) => ({
 1394 │   cognitiveLoad: 0.7,
 1395 │   stressLevel: 0.6,
 1396 │   sleepQuality: 0.8,
 1397 │   attentionLevel: 0.65,
 1398 │   uncertaintyLevel: 0.4,
 1399 │   interestAreas: ['Stress', 'Sommeil', 'Énergie']
 1400 │ });
 1401 │ 
 1402 │ // Fonction unique pour analyser les performances des recommandations
 1403 │ const analyzeRecommendationPerformance = () => ({
 1404 │   'vitamin_d3': { averageRating: 4.7, totalRatings: 120 },
 1405 │   'magnesium_glycinate': { averageRating: 4.6, totalRatings: 95 },
 1406 │   'omega3': { averageRating: 4.5, totalRatings: 150 },
 1407 │   'probiotics': { averageRating: 4.4, totalRatings: 110 },
 1408 │   'zinc': { averageRating: 4.3, totalRatings: 80 }
 1409 │ });
 1410 │ 
 1411 │ // Fonction unique pour obtenir les corrélations de motifs
 1412 │ const getPatternCorrelations = () => {
      ·       ───────────┬──────────
      ·                  ╰── `getPatternCorrelations` redefined here
 1413 │   return {
 1414 │     symptomCorrelations: {
 1415 │       "stress": ["magnesium_glycinate", "ashwagandha", "l_theanine"],
      ╰────
/home/runner/workspace/src/utils/recommenderSystem.ts:449:1
Click outside, press Esc key, or fix the code to dismiss.
You can also disable this overlay by setting server.hmr.overlay to false in vite.config.ts.
[plugin:vite:react-swc] × the name `generateDetailedRecommendationExplanation` is defined multiple times
     ╭─[/home/runner/workspace/src/utils/recommenderSystem.ts:449:1]
 446 │ /**
 447 │  * Génère une explication détaillée pour une recommandation spécifique
 448 │  */
 449 │ export const generateDetailedRecommendationExplanation = (
     ·              ────────────────────┬────────────────────
     ·                                  ╰── previous definition of `generateDetailedRecommendationExplanation` here
 450 │   recommendation: Recommendation,
 451 │   quizResponses: QuizResponse
 452 │ ): string => {
 453 │   try {
 454 │     const supplement = SUPPLEMENT_CATALOG[recommendation.id];
 455 │ 
 456 │     if (!supplement) {
 457 │       return "Information détaillée non disponible pour ce complément.";
 458 │     }
 459 │ 
 460 │     // Construire une explication scientifique personnalisée
 461 │     let explanation = `**${supplement.name} (${supplement.scientificName})** : ${supplement.description}\n\n`;
 462 │ 
 463 │     // Bénéfices spécifiques
 464 │     explanation += "**Bénéfices ciblés pour votre profil :**\n";
 465 │     explanation += supplement.benefits.map(b => `- ${b}`).join('\n');
 466 │ 
 467 │     // Base scientifique
 468 │     explanation += `\n\n**Base scientifique :** ${supplement.scientificBasis}`;
 469 │ 
 470 │     // Dosage personnalisé
 471 │     explanation += `\n\n**Dosage recommandé pour vous :** ${recommendation.recommendedDose || supplement.standardDose}`;
 472 │ 
 473 │     // Délai d'efficacité
 474 │     explanation += `\n\n**Délai d'efficacité typique :** ${supplement.timeToEffect}`;
 475 │ 
 476 │     // Précautions
 477 │     if (supplement.contraindications && supplement.contraindications.length > 0) {
 478 │       explanation += "\n\n**Précautions :** ";
 479 │       explanation += supplement.contraindications.map(c => c).join(', ');
 480 │     }
 481 │ 
 482 │     return explanation;
 483 │   } catch (error) {
 484 │     console.error("Erreur lors de la génération de l'explication:", error);
 485 │     return "Désolé, nous ne pouvons pas générer d'explication détaillée pour cette recommandation.";
 486 │   }
 487 │ };
 488 │ 
 489 │ // Helper functions for AI learning status
 490 │ export function getAILearningStatus() {
 491 │   return {
 492 │     isActive: true,
 493 │     modelVersion: '2.0.1',
 494 │     lastTrainingDate: new Date().toISOString(),
 495 │     accuracy: 0.89,
 496 │     dataPointsCount: 1750,
 497 │     uniqueProfilesCount: 1150,
 498 │     trainingHistory: [
 499 │       { date: '2023-12-15', accuracy: 0.83, dataPoints: 1200 },
 500 │       { date: '2024-02-10', accuracy: 0.87, dataPoints: 1450 },
 501 │       { date: '2024-04-05', accuracy: 0.89, dataPoints: 1750 }
 502 │     ]
 503 │   };
 504 │ }
 505 │ 
 506 │ export function evaluateDataQuality() {
 507 │   return {
 508 │     overallQuality: 0.85,
 509 │     completeness: 0.88,
 510 │     consistency: 0.83,
 511 │     relevance: 0.87
 512 │   };
 513 │ }
 514 │ 
 515 │ export function saveLearningData(quizResponses: any, recommendations: any, behavioralMetrics?: any, neuroProfile?: any) {
 516 │   console.log("Données d'apprentissage sauvegardées");
 517 │   // Simulation - dans une implémentation réelle, ces données seraient stockées
 518 │ }
 519 │ 
 520 │ export function adjustRecommendationsWithLearning(recommendations: any, quizResponses: any) {
 521 │   // Cette fonction simule l'ajustement des recommandations basé sur l'apprentissage
 522 │   return recommendations;
 523 │ }
 524 │ 
 525 │ export function optimizeRecommendations(
 526 │   baseRecommendations: any[],
 527 │   quizResponses: any,
 528 │   behavioralMetrics?: any,
 529 │   neuroProfile?: any
 530 │ ): any[] {
 531 │   // Retourne simplement les recommandations pour l'instant
 532 │   return baseRecommendations;
 533 │ }
 534 │ 
 535 │ // Exportation des fonctions principales
 536 │ const recommenderSystemUtils = {
 537 │   getComprehensiveRecommendations,
 538 │   generateRecommendations,
 539 │   enrichRecommendationsWithScientificTerms,
 540 │   generateDetailedRecommendationExplanation,
 541 │   getAILearningStatus,
 542 │   evaluateDataQuality,
 543 │   saveLearningData,
 544 │   adjustRecommendationsWithLearning,
 545 │   optimizeRecommendations,
 546 │   getAIModelDetailedStatus,
 547 │   recordLearningData,
 548 │   calculateProfileSimilarity,
 549 │   enrichRecommendationsWithExternalAI,
 550 │   updateAiModel
 551 │ };
 552 │ 
 553 │ export default recommenderSystemUtils;
 554 │ 
 555 │ // Définition d'interfaces pour les types utilisés
 556 │ interface QuizResponses {
 557 │   // Interface pour les réponses du quiz
 558 │   healthConcerns?: {
 559 │     stressLevel?: string;
 560 │     energyLevel?: string;
 561 │     sleepIssues?: string;
 562 │     focusIssues?: string;
 563 │     digestiveIssues?: string;
 564 │   };
 565 │   goals?: {
 566 │     reduceStress?: boolean;
 567 │     increaseEnergy?: boolean;
 568 │     improveSleep?: boolean;
 569 │     improveFocus?: boolean;
 570 │     improveDigestion?: boolean;
 571 │   };
 572 │ }
 573 │ 
 574 │ interface BehavioralMetrics {
 575 │   // Interface pour les métriques comportementales
 576 │   cognitiveLoad: number;
 577 │   stressLevel: number;
 578 │   sleepQuality: number;
 579 │ }
 580 │ 
 581 │ 
 582 │ /**
 583 │  * Retourne le statut du modèle d'IA actuel
 584 │  * @returns Information sur le statut du modèle d'IA
 585 │  */
 586 │ export function getAIModelDetailedStatus() {
 587 │   try {
 588 │     // Récupérer les informations depuis le moteur d'apprentissage
 589 │     const aiLearningStatus = getAILearningStatus();
 590 │ 
 591 │     // Récupérer la qualité des données
 592 │     const dataQuality = evaluateDataQuality();
 593 │ 
 594 │     // Obtenir les corrélations de motifs
 595 │     const patternCorrelations = getPatternCorrelations();
 596 │ 
 597 │     // Préparer des informations sur les recommandations les plus performantes
 598 │     const recommendationPerformance = analyzeRecommendationPerformance();
 599 │ 
 600 │     // Identifier les recommandations les plus efficaces
 601 │     const topRecommendations = Object.entries(recommendationPerformance)
 602 │       .filter(([_, data]) => data.totalRatings > 10)
 603 │       .sort((a, b) => b[1].averageRating - a[1].averageRating)
 604 │       .slice(0, 5)
 605 │       .map(([id, data]) => ({
 606 │         id,
 607 │         averageRating: data.averageRating,
 608 │         totalRatings: data.totalRatings
 609 │       }));
 610 │ 
 611 │     // Générer des insights sur l'amélioration du modèle
 612 │     const improvements = [];
 613 │ 
 614 │     if (aiLearningStatus.trainingHistory && aiLearningStatus.trainingHistory.length > 1) {
 615 │       const lastTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 1];
 616 │       const previousTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 2];
 617 │ 
 618 │       if (lastTraining.accuracy > previousTraining.accuracy) {
 619 │         const improvementPercent = ((lastTraining.accuracy - previousTraining.accuracy) / previousTraining.accuracy * 100).toFixed(1);
 620 │         improvements.push(`Précision améliorée de ${improvementPercent}% depuis la dernière version`);
 621 │       }
 622 │     }
 623 │ 
 624 │     if (aiLearningStatus.uniqueProfilesCount > 1000) {
 625 │       improvements.push(`Base de données enrichie de ${aiLearningStatus.uniqueProfilesCount} profils uniques`);
 626 │     }
 627 │ 
 628 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 629 │       improvements.push(`Affinement des corrélations symptômes-suppléments (${Object.keys(patternCorrelations.symptomCorrelations).length} motifs)`);
 630 │     }
 631 │ 
 632 │     // Ajouter des indicateurs de performance du système
 633 │     const avgUserSatisfaction = Object.values(recommendationPerformance)
 634 │       .filter(data => data.totalRatings > 0)
 635 │       .reduce((sum, data) => sum + data.averageRating, 0) / 
 636 │       Object.values(recommendationPerformance).filter(data => data.totalRatings > 0).length;
 637 │ 
 638 │     if (!isNaN(avgUserSatisfaction)) {
 639 │       const satisfactionPercentage = Math.round((avgUserSatisfaction / 5) * 100);
 640 │       improvements.push(`Taux de satisfaction utilisateur global de ${satisfactionPercentage}%`);
 641 │     }
 642 │ 
 643 │     if (Object.keys(patternCorrelations.ageCorrelations).length > 0) {
 644 │       improvements.push(`Corrélations d'âge identifiées (${Object.keys(patternCorrelations.ageCorrelations).length} segments)`);
 645 │     }
 646 │ 
 647 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 648 │       improvements.push(`Corrélations avancées entre symptômes et efficacité nutritionnelle (${Object.keys(patternCorrelations.symptomCorrelations).length} symptômes)`);
 649 │     }
 650 │ 
 651 │     // Construire et retourner l'état complet du modèle
 652 │     return {
 653 │       isActive: aiLearningStatus.isActive,
 654 │       modelVersion: aiLearningStatus.modelVersion,
 655 │       lastTrainingDate: aiLearningStatus.lastTrainingDate,
 656 │       accuracy: aiLearningStatus.accuracy,
 657 │       dataPointsAnalyzed: aiLearningStatus.dataPointsCount,
 658 │       improvements: improvements,
 659 │ 
 660 │       // Informations supplémentaires
 661 │       dataQuality: dataQuality.overallQuality,
 662 │       uniqueProfiles: aiLearningStatus.uniqueProfilesCount,
 663 │       trainingHistory: aiLearningStatus.trainingHistory,
 664 │       topPerformingRecommendations: topRecommendations,
 665 │ 
 666 │       // Métriques d'interface utilisateur
 667 │       knowledgeBase: 2500 + Math.round(aiLearningStatus.dataPointsCount / 10),
 668 │       accuracyImprovement: 2.3,
 669 │       processingTime: 234,
 670 │       userSatisfaction: 94,
 671 │       useCaseCoverage: 87,
 672 │       recommendationEfficiency: 92,
 673 │       lastUpdate: new Date().toLocaleDateString(),
 674 │     };
 675 │   } catch (error) {
 676 │     console.error("Erreur lors de la récupération du statut du modèle d'IA:", error);
 677 │ 
 678 │     // Fournir des valeurs par défaut en cas d'erreur
 679 │     return {
 680 │       isActive: true,
 681 │       modelVersion: '1.0.0',
 682 │       lastTrainingDate: new Date().toISOString(),
 683 │       accuracy: 0.87,
 684 │       dataPointsAnalyzed: 1250,
 685 │       improvements: [
 686 │         "Amélioration de la détection des profils à risque",
 687 │         "Meilleure personnalisation par âge et sexe",
 688 │         "Intégration des dernières recherches scientifiques"
 689 │       ],
 690 │       knowledgeBase: 2500,
 691 │       accuracyImprovement: 2.3,
 692 │       processingTime: 234, userSatisfaction: 94,
 693 │       useCaseCoverage: 87,
 694 │       recommendationEfficiency: 92,
 695 │       lastUpdate: new Date().toLocaleDateString(),
 696 │       topPerformingRecommendations: []
 697 │     };
 698 │   }
 699 │ }
 700 │ 
 701 │ // Extension de la fonction processBehavioralData pour inclure les interestAreas
 702 │ const processBehavioralData = (behavioralMetrics: BehavioralMetrics) => ({
 703 │   cognitiveLoad: 0.7,
 704 │   stressLevel: 0.6,
 705 │   sleepQuality: 0.8,
 706 │   attentionLevel: 0.65,
 707 │   uncertaintyLevel: 0.4,
 708 │   interestAreas: ['Stress', 'Sommeil', 'Énergie']
 709 │ });
 710 │ 
 711 │ // Fonction pour analyser les performances des recommandations
 712 │ const analyzeRecommendationPerformance = () => ({
 713 │   'vitamin_d3': { averageRating: 4.7, totalRatings: 120 },
 714 │   'magnesium_glycinate': { averageRating: 4.6, totalRatings: 95 },
 715 │   'omega3': { averageRating: 4.5, totalRatings: 150 },
 716 │   'probiotics': { averageRating: 4.4, totalRatings: 110 },
 717 │   'zinc': { averageRating: 4.3, totalRatings: 80 }
 718 │ });
 719 │ 
 720 │ // Cette fonction est utilisée à l'intérieur de getAIModelDetailedStatus,
 721 │ // donc nous la renommons ici pour éviter la duplication
 722 │ const getPatternCorrelations = () => {
 723 │   return {
 724 │     symptomCorrelations: {
 725 │       "stress": ["magnesium_glycinate", "ashwagandha", "l_theanine"],
 726 │       "fatigue": ["vitamin_b_complex", "iron", "coq10"],
 727 │       "insomnia": ["melatonin", "magnesium_glycinate", "valerian_root"],
 728 │       "digestion": ["probiotics", "digestive_enzymes", "fiber_supplement"],
 729 │       "joint_pain": ["omega3", "curcumin", "glucosamine_chondroitin"]
 730 │     },
 731 │     ageCorrelations: {
 732 │       "18-30": ["vitamin_d3", "iron", "probiotics"],
 733 │       "31-45": ["coq10", "vitamin_b_complex", "ashwagandha"],
 734 │       "46-60": ["omega3", "vitamin_d3", "magnesium_glycinate"],
 735 │       "60+": ["vitamin_d3", "calcium", "vitamin_b12"]
 736 │     },
 737 │     genderCorrelations: {
 738 │       "male": ["magnesium_glycinate", "omega3", "vitamin_d3"],
 739 │       "female": ["iron", "vitamin_b_complex", "probiotics"]
 740 │     }
 741 │   };
 742 │ }
 743 │ 
 744 │ export const generateRecommendations_original = (
 745 │   quizResponses: QuizResponse,
 746 │   behavioralMetrics?: BehavioralMetrics,
 747 │   neuroProfile?: NeuroProfile
 748 │ ): Recommendation[] => {
 749 │   try {
 750 │     // ... (Original generateRecommendations logic remains largely unchanged, but could be refactored to use the new system)
 751 │     //Example of how to integrate the new system:
 752 │     const quizData: QuizData = {
 753 │       //map quizResponses to quizData
 754 │       // ...mapping logic here...
 755 │     };
 756 │     const newRecommendations = getComprehensiveRecommendations(quizData);
 757 │     return newRecommendations;
 758 │ 
 759 │ 
 760 │   } catch (error) {
 761 │     console.error("Erreur lors de la génération desrecommandations:", error);
 762 │     return [];
 763 │   }
 764 │ };
 765 │ 
 766 │ /**
 767 │  * Génère une explication détaillée pour une recommandation spécifique
 768 │  */
 769 │ export const generateDetailedRecommendationExplanation = (
     ·              ────────────────────┬────────────────────
     ·                                  ╰── `generateDetailedRecommendationExplanation` redefined here
 770 │   recommendation: Recommendation,
 771 │   quizResponses: QuizResponse
 772 │ ): string => {
     ╰────
  × the name `getAIModelDetailedStatus` is defined multiple times
      ╭─[/home/runner/workspace/src/utils/recommenderSystem.ts:586:1]
  583 │  * Retourne le statut du modèle d'IA actuel
  584 │  * @returns Information sur le statut du modèle d'IA
  585 │  */
  586 │ export function getAIModelDetailedStatus() {
      ·                 ────────────┬───────────
      ·                             ╰── previous definition of `getAIModelDetailedStatus` here
  587 │   try {
  588 │     // Récupérer les informations depuis le moteur d'apprentissage
  589 │     const aiLearningStatus = getAILearningStatus();
  590 │ 
  591 │     // Récupérer la qualité des données
  592 │     const dataQuality = evaluateDataQuality();
  593 │ 
  594 │     // Obtenir les corrélations de motifs
  595 │     const patternCorrelations = getPatternCorrelations();
  596 │ 
  597 │     // Préparer des informations sur les recommandations les plus performantes
  598 │     const recommendationPerformance = analyzeRecommendationPerformance();
  599 │ 
  600 │     // Identifier les recommandations les plus efficaces
  601 │     const topRecommendations = Object.entries(recommendationPerformance)
  602 │       .filter(([_, data]) => data.totalRatings > 10)
  603 │       .sort((a, b) => b[1].averageRating - a[1].averageRating)
  604 │       .slice(0, 5)
  605 │       .map(([id, data]) => ({
  606 │         id,
  607 │         averageRating: data.averageRating,
  608 │         totalRatings: data.totalRatings
  609 │       }));
  610 │ 
  611 │     // Générer des insights sur l'amélioration du modèle
  612 │     const improvements = [];
  613 │ 
  614 │     if (aiLearningStatus.trainingHistory && aiLearningStatus.trainingHistory.length > 1) {
  615 │       const lastTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 1];
  616 │       const previousTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 2];
  617 │ 
  618 │       if (lastTraining.accuracy > previousTraining.accuracy) {
  619 │         const improvementPercent = ((lastTraining.accuracy - previousTraining.accuracy) / previousTraining.accuracy * 100).toFixed(1);
  620 │         improvements.push(`Précision améliorée de ${improvementPercent}% depuis la dernière version`);
  621 │       }
  622 │     }
  623 │ 
  624 │     if (aiLearningStatus.uniqueProfilesCount > 1000) {
  625 │       improvements.push(`Base de données enrichie de ${aiLearningStatus.uniqueProfilesCount} profils uniques`);
  626 │     }
  627 │ 
  628 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
  629 │       improvements.push(`Affinement des corrélations symptômes-suppléments (${Object.keys(patternCorrelations.symptomCorrelations).length} motifs)`);
  630 │     }
  631 │ 
  632 │     // Ajouter des indicateurs de performance du système
  633 │     const avgUserSatisfaction = Object.values(recommendationPerformance)
  634 │       .filter(data => data.totalRatings > 0)
  635 │       .reduce((sum, data) => sum + data.averageRating, 0) / 
  636 │       Object.values(recommendationPerformance).filter(data => data.totalRatings > 0).length;
  637 │ 
  638 │     if (!isNaN(avgUserSatisfaction)) {
  639 │       const satisfactionPercentage = Math.round((avgUserSatisfaction / 5) * 100);
  640 │       improvements.push(`Taux de satisfaction utilisateur global de ${satisfactionPercentage}%`);
  641 │     }
  642 │ 
  643 │     if (Object.keys(patternCorrelations.ageCorrelations).length > 0) {
  644 │       improvements.push(`Corrélations d'âge identifiées (${Object.keys(patternCorrelations.ageCorrelations).length} segments)`);
  645 │     }
  646 │ 
  647 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
  648 │       improvements.push(`Corrélations avancées entre symptômes et efficacité nutritionnelle (${Object.keys(patternCorrelations.symptomCorrelations).length} symptômes)`);
  649 │     }
  650 │ 
  651 │     // Construire et retourner l'état complet du modèle
  652 │     return {
  653 │       isActive: aiLearningStatus.isActive,
  654 │       modelVersion: aiLearningStatus.modelVersion,
  655 │       lastTrainingDate: aiLearningStatus.lastTrainingDate,
  656 │       accuracy: aiLearningStatus.accuracy,
  657 │       dataPointsAnalyzed: aiLearningStatus.dataPointsCount,
  658 │       improvements: improvements,
  659 │ 
  660 │       // Informations supplémentaires
  661 │       dataQuality: dataQuality.overallQuality,
  662 │       uniqueProfiles: aiLearningStatus.uniqueProfilesCount,
  663 │       trainingHistory: aiLearningStatus.trainingHistory,
  664 │       topPerformingRecommendations: topRecommendations,
  665 │ 
  666 │       // Métriques d'interface utilisateur
  667 │       knowledgeBase: 2500 + Math.round(aiLearningStatus.dataPointsCount / 10),
  668 │       accuracyImprovement: 2.3,
  669 │       processingTime: 234,
  670 │       userSatisfaction: 94,
  671 │       useCaseCoverage: 87,
  672 │       recommendationEfficiency: 92,
  673 │       lastUpdate: new Date().toLocaleDateString(),
  674 │     };
  675 │   } catch (error) {
  676 │     console.error("Erreur lors de la récupération du statut du modèle d'IA:", error);
  677 │ 
  678 │     // Fournir des valeurs par défaut en cas d'erreur
  679 │     return {
  680 │       isActive: true,
  681 │       modelVersion: '1.0.0',
  682 │       lastTrainingDate: new Date().toISOString(),
  683 │       accuracy: 0.87,
  684 │       dataPointsAnalyzed: 1250,
  685 │       improvements: [
  686 │         "Amélioration de la détection des profils à risque",
  687 │         "Meilleure personnalisation par âge et sexe",
  688 │         "Intégration des dernières recherches scientifiques"
  689 │       ],
  690 │       knowledgeBase: 2500,
  691 │       accuracyImprovement: 2.3,
  692 │       processingTime: 234, userSatisfaction: 94,
  693 │       useCaseCoverage: 87,
  694 │       recommendationEfficiency: 92,
  695 │       lastUpdate: new Date().toLocaleDateString(),
  696 │       topPerformingRecommendations: []
  697 │     };
  698 │   }
  699 │ }
  700 │ 
  701 │ // Extension de la fonction processBehavioralData pour inclure les interestAreas
  702 │ const processBehavioralData = (behavioralMetrics: BehavioralMetrics) => ({
  703 │   cognitiveLoad: 0.7,
  704 │   stressLevel: 0.6,
  705 │   sleepQuality: 0.8,
  706 │   attentionLevel: 0.65,
  707 │   uncertaintyLevel: 0.4,
  708 │   interestAreas: ['Stress', 'Sommeil', 'Énergie']
  709 │ });
  710 │ 
  711 │ // Fonction pour analyser les performances des recommandations
  712 │ const analyzeRecommendationPerformance = () => ({
  713 │   'vitamin_d3': { averageRating: 4.7, totalRatings: 120 },
  714 │   'magnesium_glycinate': { averageRating: 4.6, totalRatings: 95 },
  715 │   'omega3': { averageRating: 4.5, totalRatings: 150 },
  716 │   'probiotics': { averageRating: 4.4, totalRatings: 110 },
  717 │   'zinc': { averageRating: 4.3, totalRatings: 80 }
  718 │ });
  719 │ 
  720 │ // Cette fonction est utilisée à l'intérieur de getAIModelDetailedStatus,
  721 │ // donc nous la renommons ici pour éviter la duplication
  722 │ const getPatternCorrelations = () => {
  723 │   return {
  724 │     symptomCorrelations: {
  725 │       "stress": ["magnesium_glycinate", "ashwagandha", "l_theanine"],
  726 │       "fatigue": ["vitamin_b_complex", "iron", "coq10"],
  727 │       "insomnia": ["melatonin", "magnesium_glycinate", "valerian_root"],
  728 │       "digestion": ["probiotics", "digestive_enzymes", "fiber_supplement"],
  729 │       "joint_pain": ["omega3", "curcumin", "glucosamine_chondroitin"]
  730 │     },
  731 │     ageCorrelations: {
  732 │       "18-30": ["vitamin_d3", "iron", "probiotics"],
  733 │       "31-45": ["coq10", "vitamin_b_complex", "ashwagandha"],
  734 │       "46-60": ["omega3", "vitamin_d3", "magnesium_glycinate"],
  735 │       "60+": ["vitamin_d3", "calcium", "vitamin_b12"]
  736 │     },
  737 │     genderCorrelations: {
  738 │       "male": ["magnesium_glycinate", "omega3", "vitamin_d3"],
  739 │       "female": ["iron", "vitamin_b_complex", "probiotics"]
  740 │     }
  741 │   };
  742 │ }
  743 │ 
  744 │ export const generateRecommendations_original = (
  745 │   quizResponses: QuizResponse,
  746 │   behavioralMetrics?: BehavioralMetrics,
  747 │   neuroProfile?: NeuroProfile
  748 │ ): Recommendation[] => {
  749 │   try {
  750 │     // ... (Original generateRecommendations logic remains largely unchanged, but could be refactored to use the new system)
  751 │     //Example of how to integrate the new system:
  752 │     const quizData: QuizData = {
  753 │       //map quizResponses to quizData
  754 │       // ...mapping logic here...
  755 │     };
  756 │     const newRecommendations = getComprehensiveRecommendations(quizData);
  757 │     return newRecommendations;
  758 │ 
  759 │ 
  760 │   } catch (error) {
  761 │     console.error("Erreur lors de la génération desrecommandations:", error);
  762 │     return [];
  763 │   }
  764 │ };
  765 │ 
  766 │ /**
  767 │  * Génère une explication détaillée pour une recommandation spécifique
  768 │  */
  769 │ export const generateDetailedRecommendationExplanation = (
  770 │   recommendation: Recommendation,
  771 │   quizResponses: QuizResponse
  772 │ ): string => {
  773 │   try {
  774 │     const supplement = SUPPLEMENT_CATALOG[recommendation.id];
  775 │ 
  776 │     if (!supplement) {
  777 │       return "Information détaillée non disponible pour ce complément.";
  778 │     }
  779 │ 
  780 │     // Construire une explication scientifique personnalisée
  781 │     let explanation = `**${supplement.name} (${supplement.scientificName})** : ${supplement.description}\n\n`;
  782 │ 
  783 │     // Bénéfices spécifiques
  784 │     explanation += "**Bénéfices ciblés pour votre profil :**\n";
  785 │     explanation += supplement.benefits.map(b => `- ${b}`).join('\n');
  786 │ 
  787 │     // Base scientifique
  788 │     explanation += `\n\n**Base scientifique :** ${supplement.scientificBasis}`;
  789 │ 
  790 │     // Dosage personnalisé
  791 │     explanation += `\n\n**Dosage recommandé pour vous :** ${recommendation.recommendedDose || supplement.standardDose}`;
  792 │ 
  793 │     // Délai d'efficacité
  794 │     explanation += `\n\n**Délai d'efficacité typique :** ${supplement.timeToEffect}`;
  795 │ 
  796 │     // Précautions
  797 │     if (supplement.contraindications && supplement.contraindications.length > 0) {
  798 │       explanation += "\n\n**Précautions :** ";
  799 │       explanation += supplement.contraindications.map(c => c).join(', ');
  800 │     }
  801 │ 
  802 │     return explanation;
  803 │   } catch (error) {
  804 │     console.error("Erreur lors de la génération de l'explication:", error);
  805 │     return "Désolé, nous ne pouvons pas générer d'explication détaillée pour cette recommandation.";
  806 │   }
  807 │ };
  808 │ 
  809 │ /**
  810 │  * Enregistre les données pour l'apprentissage du système IA
  811 │  */
  812 │ export const recordLearningData = (data: LearningData): void => {
  813 │   try {
  814 │     // Récupérer les données existantes
  815 │     const existingData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  816 │ 
  817 │     // Ajouter les nouvelles données
  818 │     existingData.push(data);
  819 │ 
  820 │     // Limiter la taille des données stockées (garder les 1000 plus récentes)
  821 │     const trimmedData = existingData.slice(-1000);
  822 │ 
  823 │     // Sauvegarder les données
  824 │     secureStorageService.setItem('aiLearningData', trimmedData);
  825 │ 
  826 │   } catch (error) {
  827 │     console.error("Erreur lors de l'enregistrement des données d'apprentissage:", error);
  828 │   }
  829 │ };
  830 │ 
  831 │ /**
  832 │  * Calcule le score de similarité entre deux profils utilisateurs
  833 │  */
  834 │ export const calculateProfileSimilarity = (
  835 │   profile1: any,
  836 │   profile2: any
  837 │ ): number => {
  838 │   try {
  839 │     let similarityScore = 0;
  840 │     let totalFactors = 0;
  841 │ 
  842 │     // Comparer les symptômes actifs
  843 │     if (profile1.activeSymptoms && profile2.activeSymptoms) {
  844 │       const commonSymptoms = profile1.activeSymptoms.filter((s: string) =>
  845 │         profile2.activeSymptoms.includes(s)
  846 │       ).length;
  847 │ 
  848 │       const totalSymptoms = new Set([
  849 │         ...profile1.activeSymptoms,
  850 │         ...profile2.activeSymptoms
  851 │       ]).size;
  852 │ 
  853 │       if (totalSymptoms > 0) {
  854 │         similarityScore += (commonSymptoms / totalSymptoms) * 50; // Poids plus élevé pour les symptômes
  855 │         totalFactors += 1;
  856 │       }
  857 │     }
  858 │ 
  859 │     // Comparer les objectifs
  860 │     if (profile1.activeGoals && profile2.activeGoals) {
  861 │       const commonGoals = profile1.activeGoals.filter((g: string) =>
  862 │         profile2.activeGoals.includes(g)
  863 │       ).length;
  864 │ 
  865 │       const totalGoals = new Set([
  866 │         ...profile1.activeGoals,
  867 │         ...profile2.activeGoals
  868 │       ]).size;
  869 │ 
  870 │       if (totalGoals > 0) {
  871 │         similarityScore += (commonGoals / totalGoals) * 30;
  872 │         totalFactors += 1;
  873 │       }
  874 │     }
  875 │ 
  876 │     // Comparer les restrictions alimentaires
  877 │     if (profile1.dietaryRestrictions && profile2.dietaryRestrictions) {
  878 │       let matchingRestrictions = 0;
  879 │       let totalRestrictions = 0;
  880 │ 
  881 │       for (const key in profile1.dietaryRestrictions) {
  882 │         if (profile2.dietaryRestrictions[key] === profile1.dietaryRestrictions[key]) {
  883 │           matchingRestrictions++;
  884 │         }
  885 │         totalRestrictions++;
  886 │       }
  887 │ 
  888 │       if (totalRestrictions > 0) {
  889 │         similarityScore += (matchingRestrictions / totalRestrictions) * 20;
  890 │         totalFactors += 1;
  891 │       }
  892 │     }
  893 │ 
  894 │     // Normaliser le score
  895 │     return totalFactors > 0 ? similarityScore / totalFactors : 0;
  896 │ 
  897 │   } catch (error) {
  898 │     console.error("Erreur lors du calcul de la similarité:", error);
  899 │     return 0;
  900 │   }
  901 │ };
  902 │ 
  903 │ /**
  904 │  * Enrichit les recommandations en utilisant l'IA externe via API (ChatGPT)
  905 │  */
  906 │ export const enrichRecommendationsWithExternalAI = async (
  907 │   recommendations: Recommendation[],
  908 │   quizResponses: QuizResponse
  909 │ ): Promise<Recommendation[]> => {
  910 │   try {
  911 │     // Vérifier si la clé API est configurée
  912 │     const apiKey = secureStorageService.getItem('openai_api_key');
  913 │ 
  914 │     if (!apiKey) {
  915 │       console.log("Clé API OpenAI non configurée, impossible d'enrichir les recommandations");
  916 │       return recommendations;
  917 │     }
  918 │ 
  919 │     // Préparer les données à envoyer à l'API
  920 │     const requestData = {
  921 │       model: "gpt-4",
  922 │       messages: [
  923 │         {
  924 │           role: "system",
  925 │           content: `Vous êtes un expert en nutrition et suppléments nutritionnels. 
  926 │           Vous allez analyser les recommandations générées par notre système et les enrichir 
  927 │           avec des conseils plus personnalisés, des explications scientifiques, et des ajustements 
  928 │           de dosage si nécessaire. Restez factuel et basez vos recommandations sur la science.`
  929 │         },
  930 │         {
  931 │           role: "user",
  932 │           content: `Voici les recommandations générées par notre système et les réponses au quiz de l'utilisateur.
  933 │           Veuillez enrichir ces recommandations avec des détails supplémentaires sur l'efficacité, d'éventuelles 
  934 │           synergies entre les compléments, et affiner les dosages en fonction du profil spécifique.
  935 │ 
  936 │           RÉPONSES AU QUIZ:
  937 │           ${JSON.stringify(quizResponses, null, 2)}
  938 │ 
  939 │           RECOMMANDATIONS GÉNÉRÉES:
  940 │           ${JSON.stringify(recommendations, null, 2)}
  941 │ 
  942 │           Répondez au format JSON avec les recommandations enrichies.`
  943 │         }
  944 │       ],
  945 │       temperature: 0.7,
  946 │       max_tokens: 1500
  947 │     };
  948 │ 
  949 │     // Appeler l'API OpenAI
  950 │     const response = await fetch('https://api.openai.com/v1/chat/completions', {
  951 │       method: 'POST',
  952 │       headers: {
  953 │         'Content-Type': 'application/json',
  954 │         'Authorization': `Bearer ${apiKey}`
  955 │       },
  956 │       body: JSON.stringify(requestData)
  957 │     });
  958 │ 
  959 │     if (!response.ok) {
  960 │       throw new Error(`Erreur API: ${response.status}`);
  961 │     }
  962 │ 
  963 │     const data = await response.json();
  964 │ 
  965 │     // Extraire et parser la réponse
  966 │     try {
  967 │       const content = data.choices[0].message.content;
  968 │       const enrichedRecommendations = JSON.parse(content);
  969 │ 
  970 │       // Fusionner avec les recommandations originales
  971 │       return enrichedRecommendations.map((enriched: any, index: number) => ({
  972 │         ...recommendations[index],
  973 │         ...enriched,
  974 │         aiEnriched: true
  975 │       }));
  976 │ 
  977 │     } catch (parseError) {
  978 │       console.error("Erreur lors du parsing de la réponse AI:", parseError);
  979 │       return recommendations;
  980 │     }
  981 │ 
  982 │   } catch (error) {
  983 │     console.error("Erreur lors de l'enrichissement des recommandations par IA:", error);
  984 │     return recommendations;
  985 │   }
  986 │ };
  987 │ 
  988 │ /**
  989 │  * Met à jour le modèle d'apprentissage en fonction des retours utilisateurs
  990 │  */
  991 │ export const updateAiModel = (): void => {
  992 │   try {
  993 │     // Récupérer toutes les données d'apprentissage
  994 │     const learningData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  995 │ 
  996 │     // Récupérer les retours utilisateurs
  997 │     const userFeedback: UserFeedback[] = secureStorageService.getItem('userFeedback') || [];
  998 │ 
  999 │     if (learningData.length === 0 || userFeedback.length === 0) {
 1000 │       console.log("Pas assez de données pour mettre à jour le modèle");
 1001 │       return;
 1002 │     }
 1003 │ 
 1004 │     // Traiter les données pour améliorer les recommandations
 1005 │     processLearningDataAndFeedback(learningData, userFeedback);
 1006 │ 
 1007 │   } catch (error) {
 1008 │     console.error("Erreur lors de la mise à jour du modèle IA:", error);
 1009 │   }
 1010 │ };
 1011 │ 
 1012 │ /**
 1013 │  * Traite les données d'apprentissage et les retours utilisateurs pour améliorer le modèle
 1014 │  */
 1015 │ const processLearningDataAndFeedback = (
 1016 │   learningData: LearningData[],
 1017 │   userFeedback: UserFeedback[]
 1018 │ ): void => {
 1019 │   try {
 1020 │     // Construire un index pour associer les recommandations à leur feedback
 1021 │     const feedbackIndex = new Map<string, number[]>();
 1022 │ 
 1023 │     userFeedback.forEach(feedback => {
 1024 │       if (!feedbackIndex.has(feedback.recommendationId)) {
 1025 │         feedbackIndex.set(feedback.recommendationId, []);
 1026 │       }
 1027 │ 
 1028 │       feedbackIndex.get(feedback.recommendationId)?.push(feedback.rating);
 1029 │     });
 1030 │ 
 1031 │     // Ajuster les priorités des recommandations en fonction des retours
 1032 │     const supplementAdjustments = new Map<string, {
 1033 │       totalPositive: number;
 1034 │       totalNegative: number;
 1035 │       count: number;
 1036 │     }>();
 1037 │ 
 1038 │     // Parcourir les données d'apprentissage
 1039 │     learningData.forEach(data => {
 1040 │       data.generatedRecommendations.forEach(rec => {
 1041 │         const feedback = feedbackIndex.get(rec.id);
 1042 │ 
 1043 │         if (feedback && feedback.length > 0) {
 1044 │           // Calculer le score moyen
 1045 │           const avgRating = feedback.reduce((sum, rating) => sum + rating, 0) / feedback.length;
 1046 │ 
 1047 │           if (!supplementAdjustments.has(rec.id)) {
 1048 │             supplementAdjustments.set(rec.id, {
 1049 │               totalPositive: 0,
 1050 │               totalNegative: 0,
 1051 │               count: 0
 1052 │             });
 1053 │           }
 1054 │ 
 1055 │           const adjustment = supplementAdjustments.get(rec.id)!;
 1056 │ 
 1057 │           if (avgRating >= 3.5) {
 1058 │             adjustment.totalPositive++;
 1059 │           } else {
 1060 │             adjustment.totalNegative++;
 1061 │           }
 1062 │ 
 1063 │           adjustment.count++;
 1064 │         }
 1065 │       });
 1066 │     });
 1067 │ 
 1068 │     // Appliquer les ajustements au modèle
 1069 │     supplementAdjustments.forEach((adjustmentData, supplementId) => {
 1070 │       if (adjustmentData.count >= 5) { // Au moins 5 retours pour être significatif
 1071 │         const positiveRatio = adjustmentData.totalPositive / adjustmentData.count;
 1072 │ 
 1073 │         // Ajuster les symptômes associés
 1074 │         for (const symptomKey in SYMPTOM_RECOMMENDATIONS) {
 1075 │           const recommendations = SYMPTOM_RECOMMENDATIONS[symptomKey];
 1076 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1077 │ 
 1078 │           if (recIndex >= 0) {
 1079 │             const currentPriority = recommendations[recIndex].priority;
 1080 │ 
 1081 │             // Courbe d'ajustement plus fine basée sur les retours
 1082 │             if (positiveRatio > 0.8) { // Plus de 80% de retours positifs
 1083 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 2);
 1084 │             } else if (positiveRatio > 0.6) { // Entre 60% et 80% de retours positifs
 1085 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1086 │             } else if (positiveRatio < 0.3) { // Moins de 30% de retours positifs
 1087 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 2);
 1088 │             } else if (positiveRatio < 0.5) { // Entre 30% et 50% de retours positifs
 1089 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1090 │             }
 1091 │           }
 1092 │         }
 1093 │ 
 1094 │         // Ajuster également les objectifs associés
 1095 │         for (const goalKey in GOAL_RECOMMENDATIONS) {
 1096 │           const recommendations = GOAL_RECOMMENDATIONS[goalKey];
 1097 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1098 │ 
 1099 │           if (recIndex >= 0) {
 1100 │             const currentPriority = recommendations[recIndex].priority;
 1101 │ 
 1102 │             // Augmenter ou diminuer la priorité selon les retours
 1103 │             if (positiveRatio > 0.7) {
 1104 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1105 │             } else if (positiveRatio < 0.3) {
 1106 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1107 │             }
 1108 │           }
 1109 │         }
 1110 │       }
 1111 │     });
 1112 │ 
 1113 │     // Sauvegarder les données modifiées
 1114 │     // Note: Dans une implémentation réelle, nous sauvegarderions ces changements dans une base de données
 1115 │     // Pour cette démonstration, nous utilisons le stockage sécurisé local
 1116 │     secureStorageService.setItem('symptomRecommendationsUpdated', SYMPTOM_RECOMMENDATIONS);
 1117 │     secureStorageService.setItem('goalRecommendationsUpdated', GOAL_RECOMMENDATIONS);
 1118 │ 
 1119 │     console.log("Modèle IA mis à jour avec succès");
 1120 │ 
 1121 │   } catch (error) {
 1122 │     console.error("Erreur lors du traitement des données d'apprentissage:", error);
 1123 │   }
 1124 │ };
 1125 │ 
 1126 │ /**
 1127 │  * Génère des recommandations personnalisées avancées avec analyse comportementale et IA
 1128 │  */
 1129 │ export const generateAdvancedRecommendations = (
 1130 │   quizResponses: QuizResponse,
 1131 │   behavioralMetrics?: BehavioralMetrics,
 1132 │   neuroProfile?: NeuroProfile
 1133 │ ): Recommendation[] => {
 1134 │   try {
 1135 │     // Générer les recommandations de base using the new system.
 1136 │     const quizData: QuizData = {
 1137 │       //map quizResponses to quizData
 1138 │       // ...mapping logic here...
 1139 │     };
 1140 │     const baseRecommendations = generateRecommendations(quizData);
 1141 │ 
 1142 │     // Appliquer l'ajustement d'apprentissage IA
 1143 │     const aiEnhancedRecommendations = adjustRecommendationsWithLearning(baseRecommendations, quizResponses);
 1144 │ 
 1145 │     // Si des métriques comportementales sont disponibles, les utiliser pour affiner davantage
 1146 │     if (behavioralMetrics) {
 1147 │       const behavioralInsights = processBehavioralData(behavioralMetrics);
 1148 │ 
 1149 │       // Ajuster les priorités en fonction des domaines d'intérêt comportementaux
 1150 │       aiEnhancedRecommendations.forEach(rec => {
 1151 │         // Vérifier si cette recommandation correspond à un domaine d'intérêt
 1152 │         behavioralInsights.interestAreas.forEach(area => {
 1153 │           if (
 1154 │             (area === 'Stress' && (rec.id.includes('magnes') || rec.id.includes('ashwagandha') || rec.id.includes('theanine'))) ||
 1155 │             (area === 'Sommeil' && (rec.id.includes('melatonin') || rec.id.includes('magnes') || rec.id.includes('valerian'))) ||
 1156 │             (area === 'Énergie' && (rec.id.includes('vitaminb') || rec.id.includes('iron') || rec.id.includes('coq10'))) ||
 1157 │             (area === 'Digestion' && (rec.id.includes('probio') || rec.id.includes('enzymes') || rec.id.includes('fiber'))) ||
 1158 │             (area === 'Immunité' && (rec.id.includes('vitaminc') || rec.id.includes('vitd') || rec.id.includes('zinc')))
 1159 │           ) {
 1160 │             // Augmenter le score pour les recommandations correspondant aux intérêts
 1161 │             rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1162 │ 
 1163 │             // Ajouter une explication IA
 1164 │             if (!rec.relatedTerms) {
 1165 │               rec.relatedTerms = [];
 1166 │             }
 1167 │             rec.relatedTerms.push(`Intérêt pour ${area.toLowerCase()}`);
 1168 │           }
 1169 │         });
 1170 │ 
 1171 │         // Ajuster en fonction du niveau d'incertitude
 1172 │         if (behavioralInsights.uncertaintyLevel > 0.6 && rec.scientificBasis) {
 1173 │           // Pour les utilisateurs incertains, ajouter plus d'explications scientifiques
 1174 │           if (!rec.relatedTerms) {
 1175 │             rec.relatedTerms = [];
 1176 │           }
 1177 │           rec.relatedTerms.push("Informations détaillées priorisées");
 1178 │         }
 1179 │ 
 1180 │         // Ajuster en fonction du niveau d'attention
 1181 │         if (behavioralInsights.attentionLevel < 0.4) {
 1182 │           // Pour les utilisateurs à faible attention, donner une explication courte et directe
 1183 │           rec.description = `Recommandé pour: ${rec.categories.slice(0, 2).join(', ')}`;
 1184 │         }
 1185 │       });
 1186 │     }
 1187 │ 
 1188 │     // Enrichir avec des données de neuroProfile si disponibles
 1189 │     if (neuroProfile) {
 1190 │       aiEnhancedRecommendations.forEach(rec => {
 1191 │         if (neuroProfile.decisionStyle === 'analytical' && rec.scientificBasis) {
 1192 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1193 │ 
 1194 │           if (!rec.relatedTerms) {
 1195 │             rec.relatedTerms = [];
 1196 │           }
 1197 │           rec.relatedTerms.push("Approche analytique");
 1198 │         }
 1199 │ 
 1200 │         if (neuroProfile.decisionStyle === 'intuitive' && rec.scientificBasis.includes('rapide')) {
 1201 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1202 │ 
 1203 │           if (!rec.relatedTerms) {
 1204 │             rec.relatedTerms = [];
 1205 │           }
 1206 │           rec.relatedTerms.push("Résultats immédiats");
 1207 │         }
 1208 │ 
 1209 │         if (neuroProfile.riskTolerance === 'low' && rec.scientificBasis.includes('excellent')) {
 1210 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1211 │ 
 1212 │           if (!rec.relatedTerms) {
 1213 │             rec.relatedTerms = [];
 1214 │           }
 1215 │           rec.relatedTerms.push("Excellent profil de sécurité");
 1216 │         }
 1217 │       });
 1218 │     }
 1219 │ 
 1220 │     // Réordonner les recommandations en fonction des scores ajustés
 1221 │     aiEnhancedRecommendations.sort((a, b) => {
 1222 │       return b.relevanceScore - a.relevanceScore;
 1223 │     });
 1224 │ 
 1225 │     // Optimiser les recommandations avec l'algorithme avancé
 1226 │     const optimizedRecommendations = optimizeRecommendations(
 1227 │       aiEnhancedRecommendations,
 1228 │       quizResponses,
 1229 │       behavioralMetrics,
 1230 │       neuroProfile
 1231 │     );
 1232 │ 
 1233 │     // Enregistrer les données pour apprentissage futur
 1234 │     saveLearningData(quizResponses, optimizedRecommendations, behavioralMetrics, neuroProfile);
 1235 │ 
 1236 │     return optimizedRecommendations;
 1237 │   } catch (error) {
 1238 │     console.error("Erreur lors de la génération des recommandations avancées:", error);
 1239 │     return generateRecommendations(quizData); // Fallback to the new system
 1240 │   }
 1241 │ };
 1242 │ 
 1243 │ // Importations déjà définies plus haut dans le fichier
 1244 │ 
 1245 │ 
 1246 │ // Définition d'interfaces pour les types utilisés
 1247 │ interface QuizResponses {
 1248 │   // Interface pour les réponses du quiz
 1249 │   healthConcerns?: {
 1250 │     stressLevel?: string;
 1251 │     energyLevel?: string;
 1252 │     sleepIssues?: string;
 1253 │     focusIssues?: string;
 1254 │     digestiveIssues?: string;
 1255 │   };
 1256 │   goals?: {
 1257 │     reduceStress?: boolean;
 1258 │     increaseEnergy?: boolean;
 1259 │     improveSleep?: boolean;
 1260 │     improveFocus?: boolean;
 1261 │     improveDigestion?: boolean;
 1262 │   };
 1263 │ }
 1264 │ 
 1265 │ interface BehavioralMetrics {
 1266 │   // Interface pour les métriques comportementales
 1267 │   cognitiveLoad: number;
 1268 │   stressLevel: number;
 1269 │   sleepQuality: number;
 1270 │ }
 1271 │ 
 1272 │ 
 1273 │ 
 1274 │ /**
 1275 │  * Retourne le statut du modèle d'IA actuel
 1276 │  * @returns Information sur le statut du modèle d'IA
 1277 │  */
 1278 │ export function getAIModelDetailedStatus() {
      ·                 ────────────┬───────────
      ·                             ╰── `getAIModelDetailedStatus` redefined here
 1279 │   try {
 1280 │     // Récupérer les informations depuis le moteur d'apprentissage
 1281 │     const aiLearningStatus = getAILearningStatus();
      ╰────
  × the name `processBehavioralData` is defined multiple times
      ╭─[/home/runner/workspace/src/utils/recommenderSystem.ts:702:1]
  699 │ }
  700 │ 
  701 │ // Extension de la fonction processBehavioralData pour inclure les interestAreas
  702 │ const processBehavioralData = (behavioralMetrics: BehavioralMetrics) => ({
      ·       ──────────┬──────────
      ·                 ╰── previous definition of `processBehavioralData` here
  703 │   cognitiveLoad: 0.7,
  704 │   stressLevel: 0.6,
  705 │   sleepQuality: 0.8,
  706 │   attentionLevel: 0.65,
  707 │   uncertaintyLevel: 0.4,
  708 │   interestAreas: ['Stress', 'Sommeil', 'Énergie']
  709 │ });
  710 │ 
  711 │ // Fonction pour analyser les performances des recommandations
  712 │ const analyzeRecommendationPerformance = () => ({
  713 │   'vitamin_d3': { averageRating: 4.7, totalRatings: 120 },
  714 │   'magnesium_glycinate': { averageRating: 4.6, totalRatings: 95 },
  715 │   'omega3': { averageRating: 4.5, totalRatings: 150 },
  716 │   'probiotics': { averageRating: 4.4, totalRatings: 110 },
  717 │   'zinc': { averageRating: 4.3, totalRatings: 80 }
  718 │ });
  719 │ 
  720 │ // Cette fonction est utilisée à l'intérieur de getAIModelDetailedStatus,
  721 │ // donc nous la renommons ici pour éviter la duplication
  722 │ const getPatternCorrelations = () => {
  723 │   return {
  724 │     symptomCorrelations: {
  725 │       "stress": ["magnesium_glycinate", "ashwagandha", "l_theanine"],
  726 │       "fatigue": ["vitamin_b_complex", "iron", "coq10"],
  727 │       "insomnia": ["melatonin", "magnesium_glycinate", "valerian_root"],
  728 │       "digestion": ["probiotics", "digestive_enzymes", "fiber_supplement"],
  729 │       "joint_pain": ["omega3", "curcumin", "glucosamine_chondroitin"]
  730 │     },
  731 │     ageCorrelations: {
  732 │       "18-30": ["vitamin_d3", "iron", "probiotics"],
  733 │       "31-45": ["coq10", "vitamin_b_complex", "ashwagandha"],
  734 │       "46-60": ["omega3", "vitamin_d3", "magnesium_glycinate"],
  735 │       "60+": ["vitamin_d3", "calcium", "vitamin_b12"]
  736 │     },
  737 │     genderCorrelations: {
  738 │       "male": ["magnesium_glycinate", "omega3", "vitamin_d3"],
  739 │       "female": ["iron", "vitamin_b_complex", "probiotics"]
  740 │     }
  741 │   };
  742 │ }
  743 │ 
  744 │ export const generateRecommendations_original = (
  745 │   quizResponses: QuizResponse,
  746 │   behavioralMetrics?: BehavioralMetrics,
  747 │   neuroProfile?: NeuroProfile
  748 │ ): Recommendation[] => {
  749 │   try {
  750 │     // ... (Original generateRecommendations logic remains largely unchanged, but could be refactored to use the new system)
  751 │     //Example of how to integrate the new system:
  752 │     const quizData: QuizData = {
  753 │       //map quizResponses to quizData
  754 │       // ...mapping logic here...
  755 │     };
  756 │     const newRecommendations = getComprehensiveRecommendations(quizData);
  757 │     return newRecommendations;
  758 │ 
  759 │ 
  760 │   } catch (error) {
  761 │     console.error("Erreur lors de la génération desrecommandations:", error);
  762 │     return [];
  763 │   }
  764 │ };
  765 │ 
  766 │ /**
  767 │  * Génère une explication détaillée pour une recommandation spécifique
  768 │  */
  769 │ export const generateDetailedRecommendationExplanation = (
  770 │   recommendation: Recommendation,
  771 │   quizResponses: QuizResponse
  772 │ ): string => {
  773 │   try {
  774 │     const supplement = SUPPLEMENT_CATALOG[recommendation.id];
  775 │ 
  776 │     if (!supplement) {
  777 │       return "Information détaillée non disponible pour ce complément.";
  778 │     }
  779 │ 
  780 │     // Construire une explication scientifique personnalisée
  781 │     let explanation = `**${supplement.name} (${supplement.scientificName})** : ${supplement.description}\n\n`;
  782 │ 
  783 │     // Bénéfices spécifiques
  784 │     explanation += "**Bénéfices ciblés pour votre profil :**\n";
  785 │     explanation += supplement.benefits.map(b => `- ${b}`).join('\n');
  786 │ 
  787 │     // Base scientifique
  788 │     explanation += `\n\n**Base scientifique :** ${supplement.scientificBasis}`;
  789 │ 
  790 │     // Dosage personnalisé
  791 │     explanation += `\n\n**Dosage recommandé pour vous :** ${recommendation.recommendedDose || supplement.standardDose}`;
  792 │ 
  793 │     // Délai d'efficacité
  794 │     explanation += `\n\n**Délai d'efficacité typique :** ${supplement.timeToEffect}`;
  795 │ 
  796 │     // Précautions
  797 │     if (supplement.contraindications && supplement.contraindications.length > 0) {
  798 │       explanation += "\n\n**Précautions :** ";
  799 │       explanation += supplement.contraindications.map(c => c).join(', ');
  800 │     }
  801 │ 
  802 │     return explanation;
  803 │   } catch (error) {
  804 │     console.error("Erreur lors de la génération de l'explication:", error);
  805 │     return "Désolé, nous ne pouvons pas générer d'explication détaillée pour cette recommandation.";
  806 │   }
  807 │ };
  808 │ 
  809 │ /**
  810 │  * Enregistre les données pour l'apprentissage du système IA
  811 │  */
  812 │ export const recordLearningData = (data: LearningData): void => {
  813 │   try {
  814 │     // Récupérer les données existantes
  815 │     const existingData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  816 │ 
  817 │     // Ajouter les nouvelles données
  818 │     existingData.push(data);
  819 │ 
  820 │     // Limiter la taille des données stockées (garder les 1000 plus récentes)
  821 │     const trimmedData = existingData.slice(-1000);
  822 │ 
  823 │     // Sauvegarder les données
  824 │     secureStorageService.setItem('aiLearningData', trimmedData);
  825 │ 
  826 │   } catch (error) {
  827 │     console.error("Erreur lors de l'enregistrement des données d'apprentissage:", error);
  828 │   }
  829 │ };
  830 │ 
  831 │ /**
  832 │  * Calcule le score de similarité entre deux profils utilisateurs
  833 │  */
  834 │ export const calculateProfileSimilarity = (
  835 │   profile1: any,
  836 │   profile2: any
  837 │ ): number => {
  838 │   try {
  839 │     let similarityScore = 0;
  840 │     let totalFactors = 0;
  841 │ 
  842 │     // Comparer les symptômes actifs
  843 │     if (profile1.activeSymptoms && profile2.activeSymptoms) {
  844 │       const commonSymptoms = profile1.activeSymptoms.filter((s: string) =>
  845 │         profile2.activeSymptoms.includes(s)
  846 │       ).length;
  847 │ 
  848 │       const totalSymptoms = new Set([
  849 │         ...profile1.activeSymptoms,
  850 │         ...profile2.activeSymptoms
  851 │       ]).size;
  852 │ 
  853 │       if (totalSymptoms > 0) {
  854 │         similarityScore += (commonSymptoms / totalSymptoms) * 50; // Poids plus élevé pour les symptômes
  855 │         totalFactors += 1;
  856 │       }
  857 │     }
  858 │ 
  859 │     // Comparer les objectifs
  860 │     if (profile1.activeGoals && profile2.activeGoals) {
  861 │       const commonGoals = profile1.activeGoals.filter((g: string) =>
  862 │         profile2.activeGoals.includes(g)
  863 │       ).length;
  864 │ 
  865 │       const totalGoals = new Set([
  866 │         ...profile1.activeGoals,
  867 │         ...profile2.activeGoals
  868 │       ]).size;
  869 │ 
  870 │       if (totalGoals > 0) {
  871 │         similarityScore += (commonGoals / totalGoals) * 30;
  872 │         totalFactors += 1;
  873 │       }
  874 │     }
  875 │ 
  876 │     // Comparer les restrictions alimentaires
  877 │     if (profile1.dietaryRestrictions && profile2.dietaryRestrictions) {
  878 │       let matchingRestrictions = 0;
  879 │       let totalRestrictions = 0;
  880 │ 
  881 │       for (const key in profile1.dietaryRestrictions) {
  882 │         if (profile2.dietaryRestrictions[key] === profile1.dietaryRestrictions[key]) {
  883 │           matchingRestrictions++;
  884 │         }
  885 │         totalRestrictions++;
  886 │       }
  887 │ 
  888 │       if (totalRestrictions > 0) {
  889 │         similarityScore += (matchingRestrictions / totalRestrictions) * 20;
  890 │         totalFactors += 1;
  891 │       }
  892 │     }
  893 │ 
  894 │     // Normaliser le score
  895 │     return totalFactors > 0 ? similarityScore / totalFactors : 0;
  896 │ 
  897 │   } catch (error) {
  898 │     console.error("Erreur lors du calcul de la similarité:", error);
  899 │     return 0;
  900 │   }
  901 │ };
  902 │ 
  903 │ /**
  904 │  * Enrichit les recommandations en utilisant l'IA externe via API (ChatGPT)
  905 │  */
  906 │ export const enrichRecommendationsWithExternalAI = async (
  907 │   recommendations: Recommendation[],
  908 │   quizResponses: QuizResponse
  909 │ ): Promise<Recommendation[]> => {
  910 │   try {
  911 │     // Vérifier si la clé API est configurée
  912 │     const apiKey = secureStorageService.getItem('openai_api_key');
  913 │ 
  914 │     if (!apiKey) {
  915 │       console.log("Clé API OpenAI non configurée, impossible d'enrichir les recommandations");
  916 │       return recommendations;
  917 │     }
  918 │ 
  919 │     // Préparer les données à envoyer à l'API
  920 │     const requestData = {
  921 │       model: "gpt-4",
  922 │       messages: [
  923 │         {
  924 │           role: "system",
  925 │           content: `Vous êtes un expert en nutrition et suppléments nutritionnels. 
  926 │           Vous allez analyser les recommandations générées par notre système et les enrichir 
  927 │           avec des conseils plus personnalisés, des explications scientifiques, et des ajustements 
  928 │           de dosage si nécessaire. Restez factuel et basez vos recommandations sur la science.`
  929 │         },
  930 │         {
  931 │           role: "user",
  932 │           content: `Voici les recommandations générées par notre système et les réponses au quiz de l'utilisateur.
  933 │           Veuillez enrichir ces recommandations avec des détails supplémentaires sur l'efficacité, d'éventuelles 
  934 │           synergies entre les compléments, et affiner les dosages en fonction du profil spécifique.
  935 │ 
  936 │           RÉPONSES AU QUIZ:
  937 │           ${JSON.stringify(quizResponses, null, 2)}
  938 │ 
  939 │           RECOMMANDATIONS GÉNÉRÉES:
  940 │           ${JSON.stringify(recommendations, null, 2)}
  941 │ 
  942 │           Répondez au format JSON avec les recommandations enrichies.`
  943 │         }
  944 │       ],
  945 │       temperature: 0.7,
  946 │       max_tokens: 1500
  947 │     };
  948 │ 
  949 │     // Appeler l'API OpenAI
  950 │     const response = await fetch('https://api.openai.com/v1/chat/completions', {
  951 │       method: 'POST',
  952 │       headers: {
  953 │         'Content-Type': 'application/json',
  954 │         'Authorization': `Bearer ${apiKey}`
  955 │       },
  956 │       body: JSON.stringify(requestData)
  957 │     });
  958 │ 
  959 │     if (!response.ok) {
  960 │       throw new Error(`Erreur API: ${response.status}`);
  961 │     }
  962 │ 
  963 │     const data = await response.json();
  964 │ 
  965 │     // Extraire et parser la réponse
  966 │     try {
  967 │       const content = data.choices[0].message.content;
  968 │       const enrichedRecommendations = JSON.parse(content);
  969 │ 
  970 │       // Fusionner avec les recommandations originales
  971 │       return enrichedRecommendations.map((enriched: any, index: number) => ({
  972 │         ...recommendations[index],
  973 │         ...enriched,
  974 │         aiEnriched: true
  975 │       }));
  976 │ 
  977 │     } catch (parseError) {
  978 │       console.error("Erreur lors du parsing de la réponse AI:", parseError);
  979 │       return recommendations;
  980 │     }
  981 │ 
  982 │   } catch (error) {
  983 │     console.error("Erreur lors de l'enrichissement des recommandations par IA:", error);
  984 │     return recommendations;
  985 │   }
  986 │ };
  987 │ 
  988 │ /**
  989 │  * Met à jour le modèle d'apprentissage en fonction des retours utilisateurs
  990 │  */
  991 │ export const updateAiModel = (): void => {
  992 │   try {
  993 │     // Récupérer toutes les données d'apprentissage
  994 │     const learningData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  995 │ 
  996 │     // Récupérer les retours utilisateurs
  997 │     const userFeedback: UserFeedback[] = secureStorageService.getItem('userFeedback') || [];
  998 │ 
  999 │     if (learningData.length === 0 || userFeedback.length === 0) {
 1000 │       console.log("Pas assez de données pour mettre à jour le modèle");
 1001 │       return;
 1002 │     }
 1003 │ 
 1004 │     // Traiter les données pour améliorer les recommandations
 1005 │     processLearningDataAndFeedback(learningData, userFeedback);
 1006 │ 
 1007 │   } catch (error) {
 1008 │     console.error("Erreur lors de la mise à jour du modèle IA:", error);
 1009 │   }
 1010 │ };
 1011 │ 
 1012 │ /**
 1013 │  * Traite les données d'apprentissage et les retours utilisateurs pour améliorer le modèle
 1014 │  */
 1015 │ const processLearningDataAndFeedback = (
 1016 │   learningData: LearningData[],
 1017 │   userFeedback: UserFeedback[]
 1018 │ ): void => {
 1019 │   try {
 1020 │     // Construire un index pour associer les recommandations à leur feedback
 1021 │     const feedbackIndex = new Map<string, number[]>();
 1022 │ 
 1023 │     userFeedback.forEach(feedback => {
 1024 │       if (!feedbackIndex.has(feedback.recommendationId)) {
 1025 │         feedbackIndex.set(feedback.recommendationId, []);
 1026 │       }
 1027 │ 
 1028 │       feedbackIndex.get(feedback.recommendationId)?.push(feedback.rating);
 1029 │     });
 1030 │ 
 1031 │     // Ajuster les priorités des recommandations en fonction des retours
 1032 │     const supplementAdjustments = new Map<string, {
 1033 │       totalPositive: number;
 1034 │       totalNegative: number;
 1035 │       count: number;
 1036 │     }>();
 1037 │ 
 1038 │     // Parcourir les données d'apprentissage
 1039 │     learningData.forEach(data => {
 1040 │       data.generatedRecommendations.forEach(rec => {
 1041 │         const feedback = feedbackIndex.get(rec.id);
 1042 │ 
 1043 │         if (feedback && feedback.length > 0) {
 1044 │           // Calculer le score moyen
 1045 │           const avgRating = feedback.reduce((sum, rating) => sum + rating, 0) / feedback.length;
 1046 │ 
 1047 │           if (!supplementAdjustments.has(rec.id)) {
 1048 │             supplementAdjustments.set(rec.id, {
 1049 │               totalPositive: 0,
 1050 │               totalNegative: 0,
 1051 │               count: 0
 1052 │             });
 1053 │           }
 1054 │ 
 1055 │           const adjustment = supplementAdjustments.get(rec.id)!;
 1056 │ 
 1057 │           if (avgRating >= 3.5) {
 1058 │             adjustment.totalPositive++;
 1059 │           } else {
 1060 │             adjustment.totalNegative++;
 1061 │           }
 1062 │ 
 1063 │           adjustment.count++;
 1064 │         }
 1065 │       });
 1066 │     });
 1067 │ 
 1068 │     // Appliquer les ajustements au modèle
 1069 │     supplementAdjustments.forEach((adjustmentData, supplementId) => {
 1070 │       if (adjustmentData.count >= 5) { // Au moins 5 retours pour être significatif
 1071 │         const positiveRatio = adjustmentData.totalPositive / adjustmentData.count;
 1072 │ 
 1073 │         // Ajuster les symptômes associés
 1074 │         for (const symptomKey in SYMPTOM_RECOMMENDATIONS) {
 1075 │           const recommendations = SYMPTOM_RECOMMENDATIONS[symptomKey];
 1076 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1077 │ 
 1078 │           if (recIndex >= 0) {
 1079 │             const currentPriority = recommendations[recIndex].priority;
 1080 │ 
 1081 │             // Courbe d'ajustement plus fine basée sur les retours
 1082 │             if (positiveRatio > 0.8) { // Plus de 80% de retours positifs
 1083 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 2);
 1084 │             } else if (positiveRatio > 0.6) { // Entre 60% et 80% de retours positifs
 1085 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1086 │             } else if (positiveRatio < 0.3) { // Moins de 30% de retours positifs
 1087 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 2);
 1088 │             } else if (positiveRatio < 0.5) { // Entre 30% et 50% de retours positifs
 1089 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1090 │             }
 1091 │           }
 1092 │         }
 1093 │ 
 1094 │         // Ajuster également les objectifs associés
 1095 │         for (const goalKey in GOAL_RECOMMENDATIONS) {
 1096 │           const recommendations = GOAL_RECOMMENDATIONS[goalKey];
 1097 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1098 │ 
 1099 │           if (recIndex >= 0) {
 1100 │             const currentPriority = recommendations[recIndex].priority;
 1101 │ 
 1102 │             // Augmenter ou diminuer la priorité selon les retours
 1103 │             if (positiveRatio > 0.7) {
 1104 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1105 │             } else if (positiveRatio < 0.3) {
 1106 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1107 │             }
 1108 │           }
 1109 │         }
 1110 │       }
 1111 │     });
 1112 │ 
 1113 │     // Sauvegarder les données modifiées
 1114 │     // Note: Dans une implémentation réelle, nous sauvegarderions ces changements dans une base de données
 1115 │     // Pour cette démonstration, nous utilisons le stockage sécurisé local
 1116 │     secureStorageService.setItem('symptomRecommendationsUpdated', SYMPTOM_RECOMMENDATIONS);
 1117 │     secureStorageService.setItem('goalRecommendationsUpdated', GOAL_RECOMMENDATIONS);
 1118 │ 
 1119 │     console.log("Modèle IA mis à jour avec succès");
 1120 │ 
 1121 │   } catch (error) {
 1122 │     console.error("Erreur lors du traitement des données d'apprentissage:", error);
 1123 │   }
 1124 │ };
 1125 │ 
 1126 │ /**
 1127 │  * Génère des recommandations personnalisées avancées avec analyse comportementale et IA
 1128 │  */
 1129 │ export const generateAdvancedRecommendations = (
 1130 │   quizResponses: QuizResponse,
 1131 │   behavioralMetrics?: BehavioralMetrics,
 1132 │   neuroProfile?: NeuroProfile
 1133 │ ): Recommendation[] => {
 1134 │   try {
 1135 │     // Générer les recommandations de base using the new system.
 1136 │     const quizData: QuizData = {
 1137 │       //map quizResponses to quizData
 1138 │       // ...mapping logic here...
 1139 │     };
 1140 │     const baseRecommendations = generateRecommendations(quizData);
 1141 │ 
 1142 │     // Appliquer l'ajustement d'apprentissage IA
 1143 │     const aiEnhancedRecommendations = adjustRecommendationsWithLearning(baseRecommendations, quizResponses);
 1144 │ 
 1145 │     // Si des métriques comportementales sont disponibles, les utiliser pour affiner davantage
 1146 │     if (behavioralMetrics) {
 1147 │       const behavioralInsights = processBehavioralData(behavioralMetrics);
 1148 │ 
 1149 │       // Ajuster les priorités en fonction des domaines d'intérêt comportementaux
 1150 │       aiEnhancedRecommendations.forEach(rec => {
 1151 │         // Vérifier si cette recommandation correspond à un domaine d'intérêt
 1152 │         behavioralInsights.interestAreas.forEach(area => {
 1153 │           if (
 1154 │             (area === 'Stress' && (rec.id.includes('magnes') || rec.id.includes('ashwagandha') || rec.id.includes('theanine'))) ||
 1155 │             (area === 'Sommeil' && (rec.id.includes('melatonin') || rec.id.includes('magnes') || rec.id.includes('valerian'))) ||
 1156 │             (area === 'Énergie' && (rec.id.includes('vitaminb') || rec.id.includes('iron') || rec.id.includes('coq10'))) ||
 1157 │             (area === 'Digestion' && (rec.id.includes('probio') || rec.id.includes('enzymes') || rec.id.includes('fiber'))) ||
 1158 │             (area === 'Immunité' && (rec.id.includes('vitaminc') || rec.id.includes('vitd') || rec.id.includes('zinc')))
 1159 │           ) {
 1160 │             // Augmenter le score pour les recommandations correspondant aux intérêts
 1161 │             rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1162 │ 
 1163 │             // Ajouter une explication IA
 1164 │             if (!rec.relatedTerms) {
 1165 │               rec.relatedTerms = [];
 1166 │             }
 1167 │             rec.relatedTerms.push(`Intérêt pour ${area.toLowerCase()}`);
 1168 │           }
 1169 │         });
 1170 │ 
 1171 │         // Ajuster en fonction du niveau d'incertitude
 1172 │         if (behavioralInsights.uncertaintyLevel > 0.6 && rec.scientificBasis) {
 1173 │           // Pour les utilisateurs incertains, ajouter plus d'explications scientifiques
 1174 │           if (!rec.relatedTerms) {
 1175 │             rec.relatedTerms = [];
 1176 │           }
 1177 │           rec.relatedTerms.push("Informations détaillées priorisées");
 1178 │         }
 1179 │ 
 1180 │         // Ajuster en fonction du niveau d'attention
 1181 │         if (behavioralInsights.attentionLevel < 0.4) {
 1182 │           // Pour les utilisateurs à faible attention, donner une explication courte et directe
 1183 │           rec.description = `Recommandé pour: ${rec.categories.slice(0, 2).join(', ')}`;
 1184 │         }
 1185 │       });
 1186 │     }
 1187 │ 
 1188 │     // Enrichir avec des données de neuroProfile si disponibles
 1189 │     if (neuroProfile) {
 1190 │       aiEnhancedRecommendations.forEach(rec => {
 1191 │         if (neuroProfile.decisionStyle === 'analytical' && rec.scientificBasis) {
 1192 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1193 │ 
 1194 │           if (!rec.relatedTerms) {
 1195 │             rec.relatedTerms = [];
 1196 │           }
 1197 │           rec.relatedTerms.push("Approche analytique");
 1198 │         }
 1199 │ 
 1200 │         if (neuroProfile.decisionStyle === 'intuitive' && rec.scientificBasis.includes('rapide')) {
 1201 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1202 │ 
 1203 │           if (!rec.relatedTerms) {
 1204 │             rec.relatedTerms = [];
 1205 │           }
 1206 │           rec.relatedTerms.push("Résultats immédiats");
 1207 │         }
 1208 │ 
 1209 │         if (neuroProfile.riskTolerance === 'low' && rec.scientificBasis.includes('excellent')) {
 1210 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1211 │ 
 1212 │           if (!rec.relatedTerms) {
 1213 │             rec.relatedTerms = [];
 1214 │           }
 1215 │           rec.relatedTerms.push("Excellent profil de sécurité");
 1216 │         }
 1217 │       });
 1218 │     }
 1219 │ 
 1220 │     // Réordonner les recommandations en fonction des scores ajustés
 1221 │     aiEnhancedRecommendations.sort((a, b) => {
 1222 │       return b.relevanceScore - a.relevanceScore;
 1223 │     });
 1224 │ 
 1225 │     // Optimiser les recommandations avec l'algorithme avancé
 1226 │     const optimizedRecommendations = optimizeRecommendations(
 1227 │       aiEnhancedRecommendations,
 1228 │       quizResponses,
 1229 │       behavioralMetrics,
 1230 │       neuroProfile
 1231 │     );
 1232 │ 
 1233 │     // Enregistrer les données pour apprentissage futur
 1234 │     saveLearningData(quizResponses, optimizedRecommendations, behavioralMetrics, neuroProfile);
 1235 │ 
 1236 │     return optimizedRecommendations;
 1237 │   } catch (error) {
 1238 │     console.error("Erreur lors de la génération des recommandations avancées:", error);
 1239 │     return generateRecommendations(quizData); // Fallback to the new system
 1240 │   }
 1241 │ };
 1242 │ 
 1243 │ // Importations déjà définies plus haut dans le fichier
 1244 │ 
 1245 │ 
 1246 │ // Définition d'interfaces pour les types utilisés
 1247 │ interface QuizResponses {
 1248 │   // Interface pour les réponses du quiz
 1249 │   healthConcerns?: {
 1250 │     stressLevel?: string;
 1251 │     energyLevel?: string;
 1252 │     sleepIssues?: string;
 1253 │     focusIssues?: string;
 1254 │     digestiveIssues?: string;
 1255 │   };
 1256 │   goals?: {
 1257 │     reduceStress?: boolean;
 1258 │     increaseEnergy?: boolean;
 1259 │     improveSleep?: boolean;
 1260 │     improveFocus?: boolean;
 1261 │     improveDigestion?: boolean;
 1262 │   };
 1263 │ }
 1264 │ 
 1265 │ interface BehavioralMetrics {
 1266 │   // Interface pour les métriques comportementales
 1267 │   cognitiveLoad: number;
 1268 │   stressLevel: number;
 1269 │   sleepQuality: number;
 1270 │ }
 1271 │ 
 1272 │ 
 1273 │ 
 1274 │ /**
 1275 │  * Retourne le statut du modèle d'IA actuel
 1276 │  * @returns Information sur le statut du modèle d'IA
 1277 │  */
 1278 │ export function getAIModelDetailedStatus() {
 1279 │   try {
 1280 │     // Récupérer les informations depuis le moteur d'apprentissage
 1281 │     const aiLearningStatus = getAILearningStatus();
 1282 │ 
 1283 │     // Récupérer la qualité des données
 1284 │     const dataQuality = evaluateDataQuality();
 1285 │ 
 1286 │     // Obtenir les corrélations de motifs
 1287 │     const patternCorrelations = getPatternCorrelations();
 1288 │ 
 1289 │     // Préparer des informations sur les recommandations les plus performantes
 1290 │     const recommendationPerformance = analyzeRecommendationPerformance();
 1291 │ 
 1292 │     // Identifier les recommandations les plus efficaces
 1293 │     const topRecommendations = Object.entries(recommendationPerformance)
 1294 │       .filter(([_, data]) => data.totalRatings > 10)
 1295 │       .sort((a, b) => b[1].averageRating - a[1].averageRating)
 1296 │       .slice(0, 5)
 1297 │       .map(([id, data]) => ({
 1298 │         id,
 1299 │         averageRating: data.averageRating,
 1300 │         totalRatings: data.totalRatings
 1301 │       }));
 1302 │ 
 1303 │     // Générer des insights sur l'amélioration du modèle
 1304 │     const improvements = [];
 1305 │ 
 1306 │     if (aiLearningStatus.trainingHistory && aiLearningStatus.trainingHistory.length > 1) {
 1307 │       const lastTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 1];
 1308 │       const previousTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 2];
 1309 │ 
 1310 │       if (lastTraining.accuracy > previousTraining.accuracy) {
 1311 │         const improvementPercent = ((lastTraining.accuracy - previousTraining.accuracy) / previousTraining.accuracy * 100).toFixed(1);
 1312 │         improvements.push(`Précision améliorée de ${improvementPercent}% depuis la dernière version`);
 1313 │       }
 1314 │     }
 1315 │ 
 1316 │     if (aiLearningStatus.uniqueProfilesCount > 1000) {
 1317 │       improvements.push(`Base de données enrichie de ${aiLearningStatus.uniqueProfilesCount} profils uniques`);
 1318 │     }
 1319 │ 
 1320 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 1321 │       improvements.push(`Affinement des corrélations symptômes-suppléments (${Object.keys(patternCorrelations.symptomCorrelations).length} motifs)`);
 1322 │     }
 1323 │ 
 1324 │     // Ajouter des indicateurs de performance du système
 1325 │     const avgUserSatisfaction = Object.values(recommendationPerformance)
 1326 │       .filter(data => data.totalRatings > 0)
 1327 │       .reduce((sum, data) => sum + data.averageRating, 0) /
 1328 │       Object.values(recommendationPerformance).filter(data => data.totalRatings > 0).length;
 1329 │ 
 1330 │     if (!isNaN(avgUserSatisfaction)) {
 1331 │       const satisfactionPercentage = Math.round((avgUserSatisfaction / 5) * 100);
 1332 │       improvements.push(`Taux de satisfaction utilisateur global de ${satisfactionPercentage}%`);
 1333 │     }
 1334 │ 
 1335 │     if (Object.keys(patternCorrelations.ageCorrelations).length > 0) {
 1336 │       improvements.push(`Corrélations d'âge identifiées (${Object.keys(patternCorrelations.ageCorrelations).length} segments)`);
 1337 │     }
 1338 │ 
 1339 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 1340 │       improvements.push(`Corrélations avancées entre symptômes et efficacité nutritionnelle (${Object.keys(patternCorrelations.symptomCorrelations).length} symptômes)`);
 1341 │     }
 1342 │ 
 1343 │     // Construire et retourner l'état complet du modèle
 1344 │     return {
 1345 │       isActive: aiLearningStatus.isActive,
 1346 │       modelVersion: aiLearningStatus.modelVersion,
 1347 │       lastTrainingDate: aiLearningStatus.lastTrainingDate,
 1348 │       accuracy: aiLearningStatus.accuracy,
 1349 │       dataPointsAnalyzed: aiLearningStatus.dataPointsCount,
 1350 │       improvements: improvements,
 1351 │ 
 1352 │       // Informations supplémentaires
 1353 │       dataQuality: dataQuality.overallQuality,
 1354 │       uniqueProfiles: aiLearningStatus.uniqueProfilesCount,
 1355 │       trainingHistory: aiLearningStatus.trainingHistory,
 1356 │       topPerformingRecommendations: topRecommendations,
 1357 │ 
 1358 │       // Métriques d'interface utilisateur
 1359 │       knowledgeBase: 2500 + Math.round(aiLearningStatus.dataPointsCount / 10),
 1360 │       accuracyImprovement: 2.3,
 1361 │       processingTime: 234,
 1362 │       userSatisfaction: 94,
 1363 │       useCaseCoverage: 87,
 1364 │       recommendationEfficiency: 92,
 1365 │       lastUpdate: new Date().toLocaleDateString(),
 1366 │     };
 1367 │   } catch (error) {
 1368 │     console.error("Erreur lors de la récupération du statut du modèle d'IA:", error);
 1369 │ 
 1370 │     // Fournir des valeurs par défaut en cas d'erreur
 1371 │     return {
 1372 │       isActive: true,
 1373 │       modelVersion: '1.0.0',
 1374 │       lastTrainingDate: new Date().toISOString(),
 1375 │       accuracy: 0.87,
 1376 │       dataPointsAnalyzed: 1250,
 1377 │       improvements: [
 1378 │         "Amélioration de la détection des profils à risque",
 1379 │         "Meilleure personnalisation par âge et sexe",
 1380 │         "Intégration des dernières recherches scientifiques"
 1381 │       ],
 1382 │       knowledgeBase: 2500,
 1383 │       accuracyImprovement: 2.3,
 1384 │       processingTime: 234, userSatisfaction: 94,
 1385 │       useCaseCoverage: 87,
 1386 │       recommendationEfficiency: 92,
 1387 │       lastUpdate: new Date().toLocaleDateString(),
 1388 │       topPerformingRecommendations: []
 1389 │     };
 1390 │   }
 1391 │ }
 1392 │ 
 1393 │ // Extension de la fonction processBehavioralData pour inclure les interestAreas
 1394 │ const processBehavioralData = (behavioralMetrics: BehavioralMetrics) => ({
      ·       ──────────┬──────────
      ·                 ╰── `processBehavioralData` redefined here
 1395 │   cognitiveLoad: 0.7,
 1396 │   stressLevel: 0.6,
 1397 │   sleepQuality: 0.8,
      ╰────
  × the name `analyzeRecommendationPerformance` is defined multiple times
      ╭─[/home/runner/workspace/src/utils/recommenderSystem.ts:712:1]
  709 │ });
  710 │ 
  711 │ // Fonction pour analyser les performances des recommandations
  712 │ const analyzeRecommendationPerformance = () => ({
      ·       ────────────────┬───────────────
      ·                       ╰── previous definition of `analyzeRecommendationPerformance` here
  713 │   'vitamin_d3': { averageRating: 4.7, totalRatings: 120 },
  714 │   'magnesium_glycinate': { averageRating: 4.6, totalRatings: 95 },
  715 │   'omega3': { averageRating: 4.5, totalRatings: 150 },
  716 │   'probiotics': { averageRating: 4.4, totalRatings: 110 },
  717 │   'zinc': { averageRating: 4.3, totalRatings: 80 }
  718 │ });
  719 │ 
  720 │ // Cette fonction est utilisée à l'intérieur de getAIModelDetailedStatus,
  721 │ // donc nous la renommons ici pour éviter la duplication
  722 │ const getPatternCorrelations = () => {
  723 │   return {
  724 │     symptomCorrelations: {
  725 │       "stress": ["magnesium_glycinate", "ashwagandha", "l_theanine"],
  726 │       "fatigue": ["vitamin_b_complex", "iron", "coq10"],
  727 │       "insomnia": ["melatonin", "magnesium_glycinate", "valerian_root"],
  728 │       "digestion": ["probiotics", "digestive_enzymes", "fiber_supplement"],
  729 │       "joint_pain": ["omega3", "curcumin", "glucosamine_chondroitin"]
  730 │     },
  731 │     ageCorrelations: {
  732 │       "18-30": ["vitamin_d3", "iron", "probiotics"],
  733 │       "31-45": ["coq10", "vitamin_b_complex", "ashwagandha"],
  734 │       "46-60": ["omega3", "vitamin_d3", "magnesium_glycinate"],
  735 │       "60+": ["vitamin_d3", "calcium", "vitamin_b12"]
  736 │     },
  737 │     genderCorrelations: {
  738 │       "male": ["magnesium_glycinate", "omega3", "vitamin_d3"],
  739 │       "female": ["iron", "vitamin_b_complex", "probiotics"]
  740 │     }
  741 │   };
  742 │ }
  743 │ 
  744 │ export const generateRecommendations_original = (
  745 │   quizResponses: QuizResponse,
  746 │   behavioralMetrics?: BehavioralMetrics,
  747 │   neuroProfile?: NeuroProfile
  748 │ ): Recommendation[] => {
  749 │   try {
  750 │     // ... (Original generateRecommendations logic remains largely unchanged, but could be refactored to use the new system)
  751 │     //Example of how to integrate the new system:
  752 │     const quizData: QuizData = {
  753 │       //map quizResponses to quizData
  754 │       // ...mapping logic here...
  755 │     };
  756 │     const newRecommendations = getComprehensiveRecommendations(quizData);
  757 │     return newRecommendations;
  758 │ 
  759 │ 
  760 │   } catch (error) {
  761 │     console.error("Erreur lors de la génération desrecommandations:", error);
  762 │     return [];
  763 │   }
  764 │ };
  765 │ 
  766 │ /**
  767 │  * Génère une explication détaillée pour une recommandation spécifique
  768 │  */
  769 │ export const generateDetailedRecommendationExplanation = (
  770 │   recommendation: Recommendation,
  771 │   quizResponses: QuizResponse
  772 │ ): string => {
  773 │   try {
  774 │     const supplement = SUPPLEMENT_CATALOG[recommendation.id];
  775 │ 
  776 │     if (!supplement) {
  777 │       return "Information détaillée non disponible pour ce complément.";
  778 │     }
  779 │ 
  780 │     // Construire une explication scientifique personnalisée
  781 │     let explanation = `**${supplement.name} (${supplement.scientificName})** : ${supplement.description}\n\n`;
  782 │ 
  783 │     // Bénéfices spécifiques
  784 │     explanation += "**Bénéfices ciblés pour votre profil :**\n";
  785 │     explanation += supplement.benefits.map(b => `- ${b}`).join('\n');
  786 │ 
  787 │     // Base scientifique
  788 │     explanation += `\n\n**Base scientifique :** ${supplement.scientificBasis}`;
  789 │ 
  790 │     // Dosage personnalisé
  791 │     explanation += `\n\n**Dosage recommandé pour vous :** ${recommendation.recommendedDose || supplement.standardDose}`;
  792 │ 
  793 │     // Délai d'efficacité
  794 │     explanation += `\n\n**Délai d'efficacité typique :** ${supplement.timeToEffect}`;
  795 │ 
  796 │     // Précautions
  797 │     if (supplement.contraindications && supplement.contraindications.length > 0) {
  798 │       explanation += "\n\n**Précautions :** ";
  799 │       explanation += supplement.contraindications.map(c => c).join(', ');
  800 │     }
  801 │ 
  802 │     return explanation;
  803 │   } catch (error) {
  804 │     console.error("Erreur lors de la génération de l'explication:", error);
  805 │     return "Désolé, nous ne pouvons pas générer d'explication détaillée pour cette recommandation.";
  806 │   }
  807 │ };
  808 │ 
  809 │ /**
  810 │  * Enregistre les données pour l'apprentissage du système IA
  811 │  */
  812 │ export const recordLearningData = (data: LearningData): void => {
  813 │   try {
  814 │     // Récupérer les données existantes
  815 │     const existingData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  816 │ 
  817 │     // Ajouter les nouvelles données
  818 │     existingData.push(data);
  819 │ 
  820 │     // Limiter la taille des données stockées (garder les 1000 plus récentes)
  821 │     const trimmedData = existingData.slice(-1000);
  822 │ 
  823 │     // Sauvegarder les données
  824 │     secureStorageService.setItem('aiLearningData', trimmedData);
  825 │ 
  826 │   } catch (error) {
  827 │     console.error("Erreur lors de l'enregistrement des données d'apprentissage:", error);
  828 │   }
  829 │ };
  830 │ 
  831 │ /**
  832 │  * Calcule le score de similarité entre deux profils utilisateurs
  833 │  */
  834 │ export const calculateProfileSimilarity = (
  835 │   profile1: any,
  836 │   profile2: any
  837 │ ): number => {
  838 │   try {
  839 │     let similarityScore = 0;
  840 │     let totalFactors = 0;
  841 │ 
  842 │     // Comparer les symptômes actifs
  843 │     if (profile1.activeSymptoms && profile2.activeSymptoms) {
  844 │       const commonSymptoms = profile1.activeSymptoms.filter((s: string) =>
  845 │         profile2.activeSymptoms.includes(s)
  846 │       ).length;
  847 │ 
  848 │       const totalSymptoms = new Set([
  849 │         ...profile1.activeSymptoms,
  850 │         ...profile2.activeSymptoms
  851 │       ]).size;
  852 │ 
  853 │       if (totalSymptoms > 0) {
  854 │         similarityScore += (commonSymptoms / totalSymptoms) * 50; // Poids plus élevé pour les symptômes
  855 │         totalFactors += 1;
  856 │       }
  857 │     }
  858 │ 
  859 │     // Comparer les objectifs
  860 │     if (profile1.activeGoals && profile2.activeGoals) {
  861 │       const commonGoals = profile1.activeGoals.filter((g: string) =>
  862 │         profile2.activeGoals.includes(g)
  863 │       ).length;
  864 │ 
  865 │       const totalGoals = new Set([
  866 │         ...profile1.activeGoals,
  867 │         ...profile2.activeGoals
  868 │       ]).size;
  869 │ 
  870 │       if (totalGoals > 0) {
  871 │         similarityScore += (commonGoals / totalGoals) * 30;
  872 │         totalFactors += 1;
  873 │       }
  874 │     }
  875 │ 
  876 │     // Comparer les restrictions alimentaires
  877 │     if (profile1.dietaryRestrictions && profile2.dietaryRestrictions) {
  878 │       let matchingRestrictions = 0;
  879 │       let totalRestrictions = 0;
  880 │ 
  881 │       for (const key in profile1.dietaryRestrictions) {
  882 │         if (profile2.dietaryRestrictions[key] === profile1.dietaryRestrictions[key]) {
  883 │           matchingRestrictions++;
  884 │         }
  885 │         totalRestrictions++;
  886 │       }
  887 │ 
  888 │       if (totalRestrictions > 0) {
  889 │         similarityScore += (matchingRestrictions / totalRestrictions) * 20;
  890 │         totalFactors += 1;
  891 │       }
  892 │     }
  893 │ 
  894 │     // Normaliser le score
  895 │     return totalFactors > 0 ? similarityScore / totalFactors : 0;
  896 │ 
  897 │   } catch (error) {
  898 │     console.error("Erreur lors du calcul de la similarité:", error);
  899 │     return 0;
  900 │   }
  901 │ };
  902 │ 
  903 │ /**
  904 │  * Enrichit les recommandations en utilisant l'IA externe via API (ChatGPT)
  905 │  */
  906 │ export const enrichRecommendationsWithExternalAI = async (
  907 │   recommendations: Recommendation[],
  908 │   quizResponses: QuizResponse
  909 │ ): Promise<Recommendation[]> => {
  910 │   try {
  911 │     // Vérifier si la clé API est configurée
  912 │     const apiKey = secureStorageService.getItem('openai_api_key');
  913 │ 
  914 │     if (!apiKey) {
  915 │       console.log("Clé API OpenAI non configurée, impossible d'enrichir les recommandations");
  916 │       return recommendations;
  917 │     }
  918 │ 
  919 │     // Préparer les données à envoyer à l'API
  920 │     const requestData = {
  921 │       model: "gpt-4",
  922 │       messages: [
  923 │         {
  924 │           role: "system",
  925 │           content: `Vous êtes un expert en nutrition et suppléments nutritionnels. 
  926 │           Vous allez analyser les recommandations générées par notre système et les enrichir 
  927 │           avec des conseils plus personnalisés, des explications scientifiques, et des ajustements 
  928 │           de dosage si nécessaire. Restez factuel et basez vos recommandations sur la science.`
  929 │         },
  930 │         {
  931 │           role: "user",
  932 │           content: `Voici les recommandations générées par notre système et les réponses au quiz de l'utilisateur.
  933 │           Veuillez enrichir ces recommandations avec des détails supplémentaires sur l'efficacité, d'éventuelles 
  934 │           synergies entre les compléments, et affiner les dosages en fonction du profil spécifique.
  935 │ 
  936 │           RÉPONSES AU QUIZ:
  937 │           ${JSON.stringify(quizResponses, null, 2)}
  938 │ 
  939 │           RECOMMANDATIONS GÉNÉRÉES:
  940 │           ${JSON.stringify(recommendations, null, 2)}
  941 │ 
  942 │           Répondez au format JSON avec les recommandations enrichies.`
  943 │         }
  944 │       ],
  945 │       temperature: 0.7,
  946 │       max_tokens: 1500
  947 │     };
  948 │ 
  949 │     // Appeler l'API OpenAI
  950 │     const response = await fetch('https://api.openai.com/v1/chat/completions', {
  951 │       method: 'POST',
  952 │       headers: {
  953 │         'Content-Type': 'application/json',
  954 │         'Authorization': `Bearer ${apiKey}`
  955 │       },
  956 │       body: JSON.stringify(requestData)
  957 │     });
  958 │ 
  959 │     if (!response.ok) {
  960 │       throw new Error(`Erreur API: ${response.status}`);
  961 │     }
  962 │ 
  963 │     const data = await response.json();
  964 │ 
  965 │     // Extraire et parser la réponse
  966 │     try {
  967 │       const content = data.choices[0].message.content;
  968 │       const enrichedRecommendations = JSON.parse(content);
  969 │ 
  970 │       // Fusionner avec les recommandations originales
  971 │       return enrichedRecommendations.map((enriched: any, index: number) => ({
  972 │         ...recommendations[index],
  973 │         ...enriched,
  974 │         aiEnriched: true
  975 │       }));
  976 │ 
  977 │     } catch (parseError) {
  978 │       console.error("Erreur lors du parsing de la réponse AI:", parseError);
  979 │       return recommendations;
  980 │     }
  981 │ 
  982 │   } catch (error) {
  983 │     console.error("Erreur lors de l'enrichissement des recommandations par IA:", error);
  984 │     return recommendations;
  985 │   }
  986 │ };
  987 │ 
  988 │ /**
  989 │  * Met à jour le modèle d'apprentissage en fonction des retours utilisateurs
  990 │  */
  991 │ export const updateAiModel = (): void => {
  992 │   try {
  993 │     // Récupérer toutes les données d'apprentissage
  994 │     const learningData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  995 │ 
  996 │     // Récupérer les retours utilisateurs
  997 │     const userFeedback: UserFeedback[] = secureStorageService.getItem('userFeedback') || [];
  998 │ 
  999 │     if (learningData.length === 0 || userFeedback.length === 0) {
 1000 │       console.log("Pas assez de données pour mettre à jour le modèle");
 1001 │       return;
 1002 │     }
 1003 │ 
 1004 │     // Traiter les données pour améliorer les recommandations
 1005 │     processLearningDataAndFeedback(learningData, userFeedback);
 1006 │ 
 1007 │   } catch (error) {
 1008 │     console.error("Erreur lors de la mise à jour du modèle IA:", error);
 1009 │   }
 1010 │ };
 1011 │ 
 1012 │ /**
 1013 │  * Traite les données d'apprentissage et les retours utilisateurs pour améliorer le modèle
 1014 │  */
 1015 │ const processLearningDataAndFeedback = (
 1016 │   learningData: LearningData[],
 1017 │   userFeedback: UserFeedback[]
 1018 │ ): void => {
 1019 │   try {
 1020 │     // Construire un index pour associer les recommandations à leur feedback
 1021 │     const feedbackIndex = new Map<string, number[]>();
 1022 │ 
 1023 │     userFeedback.forEach(feedback => {
 1024 │       if (!feedbackIndex.has(feedback.recommendationId)) {
 1025 │         feedbackIndex.set(feedback.recommendationId, []);
 1026 │       }
 1027 │ 
 1028 │       feedbackIndex.get(feedback.recommendationId)?.push(feedback.rating);
 1029 │     });
 1030 │ 
 1031 │     // Ajuster les priorités des recommandations en fonction des retours
 1032 │     const supplementAdjustments = new Map<string, {
 1033 │       totalPositive: number;
 1034 │       totalNegative: number;
 1035 │       count: number;
 1036 │     }>();
 1037 │ 
 1038 │     // Parcourir les données d'apprentissage
 1039 │     learningData.forEach(data => {
 1040 │       data.generatedRecommendations.forEach(rec => {
 1041 │         const feedback = feedbackIndex.get(rec.id);
 1042 │ 
 1043 │         if (feedback && feedback.length > 0) {
 1044 │           // Calculer le score moyen
 1045 │           const avgRating = feedback.reduce((sum, rating) => sum + rating, 0) / feedback.length;
 1046 │ 
 1047 │           if (!supplementAdjustments.has(rec.id)) {
 1048 │             supplementAdjustments.set(rec.id, {
 1049 │               totalPositive: 0,
 1050 │               totalNegative: 0,
 1051 │               count: 0
 1052 │             });
 1053 │           }
 1054 │ 
 1055 │           const adjustment = supplementAdjustments.get(rec.id)!;
 1056 │ 
 1057 │           if (avgRating >= 3.5) {
 1058 │             adjustment.totalPositive++;
 1059 │           } else {
 1060 │             adjustment.totalNegative++;
 1061 │           }
 1062 │ 
 1063 │           adjustment.count++;
 1064 │         }
 1065 │       });
 1066 │     });
 1067 │ 
 1068 │     // Appliquer les ajustements au modèle
 1069 │     supplementAdjustments.forEach((adjustmentData, supplementId) => {
 1070 │       if (adjustmentData.count >= 5) { // Au moins 5 retours pour être significatif
 1071 │         const positiveRatio = adjustmentData.totalPositive / adjustmentData.count;
 1072 │ 
 1073 │         // Ajuster les symptômes associés
 1074 │         for (const symptomKey in SYMPTOM_RECOMMENDATIONS) {
 1075 │           const recommendations = SYMPTOM_RECOMMENDATIONS[symptomKey];
 1076 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1077 │ 
 1078 │           if (recIndex >= 0) {
 1079 │             const currentPriority = recommendations[recIndex].priority;
 1080 │ 
 1081 │             // Courbe d'ajustement plus fine basée sur les retours
 1082 │             if (positiveRatio > 0.8) { // Plus de 80% de retours positifs
 1083 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 2);
 1084 │             } else if (positiveRatio > 0.6) { // Entre 60% et 80% de retours positifs
 1085 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1086 │             } else if (positiveRatio < 0.3) { // Moins de 30% de retours positifs
 1087 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 2);
 1088 │             } else if (positiveRatio < 0.5) { // Entre 30% et 50% de retours positifs
 1089 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1090 │             }
 1091 │           }
 1092 │         }
 1093 │ 
 1094 │         // Ajuster également les objectifs associés
 1095 │         for (const goalKey in GOAL_RECOMMENDATIONS) {
 1096 │           const recommendations = GOAL_RECOMMENDATIONS[goalKey];
 1097 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1098 │ 
 1099 │           if (recIndex >= 0) {
 1100 │             const currentPriority = recommendations[recIndex].priority;
 1101 │ 
 1102 │             // Augmenter ou diminuer la priorité selon les retours
 1103 │             if (positiveRatio > 0.7) {
 1104 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1105 │             } else if (positiveRatio < 0.3) {
 1106 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1107 │             }
 1108 │           }
 1109 │         }
 1110 │       }
 1111 │     });
 1112 │ 
 1113 │     // Sauvegarder les données modifiées
 1114 │     // Note: Dans une implémentation réelle, nous sauvegarderions ces changements dans une base de données
 1115 │     // Pour cette démonstration, nous utilisons le stockage sécurisé local
 1116 │     secureStorageService.setItem('symptomRecommendationsUpdated', SYMPTOM_RECOMMENDATIONS);
 1117 │     secureStorageService.setItem('goalRecommendationsUpdated', GOAL_RECOMMENDATIONS);
 1118 │ 
 1119 │     console.log("Modèle IA mis à jour avec succès");
 1120 │ 
 1121 │   } catch (error) {
 1122 │     console.error("Erreur lors du traitement des données d'apprentissage:", error);
 1123 │   }
 1124 │ };
 1125 │ 
 1126 │ /**
 1127 │  * Génère des recommandations personnalisées avancées avec analyse comportementale et IA
 1128 │  */
 1129 │ export const generateAdvancedRecommendations = (
 1130 │   quizResponses: QuizResponse,
 1131 │   behavioralMetrics?: BehavioralMetrics,
 1132 │   neuroProfile?: NeuroProfile
 1133 │ ): Recommendation[] => {
 1134 │   try {
 1135 │     // Générer les recommandations de base using the new system.
 1136 │     const quizData: QuizData = {
 1137 │       //map quizResponses to quizData
 1138 │       // ...mapping logic here...
 1139 │     };
 1140 │     const baseRecommendations = generateRecommendations(quizData);
 1141 │ 
 1142 │     // Appliquer l'ajustement d'apprentissage IA
 1143 │     const aiEnhancedRecommendations = adjustRecommendationsWithLearning(baseRecommendations, quizResponses);
 1144 │ 
 1145 │     // Si des métriques comportementales sont disponibles, les utiliser pour affiner davantage
 1146 │     if (behavioralMetrics) {
 1147 │       const behavioralInsights = processBehavioralData(behavioralMetrics);
 1148 │ 
 1149 │       // Ajuster les priorités en fonction des domaines d'intérêt comportementaux
 1150 │       aiEnhancedRecommendations.forEach(rec => {
 1151 │         // Vérifier si cette recommandation correspond à un domaine d'intérêt
 1152 │         behavioralInsights.interestAreas.forEach(area => {
 1153 │           if (
 1154 │             (area === 'Stress' && (rec.id.includes('magnes') || rec.id.includes('ashwagandha') || rec.id.includes('theanine'))) ||
 1155 │             (area === 'Sommeil' && (rec.id.includes('melatonin') || rec.id.includes('magnes') || rec.id.includes('valerian'))) ||
 1156 │             (area === 'Énergie' && (rec.id.includes('vitaminb') || rec.id.includes('iron') || rec.id.includes('coq10'))) ||
 1157 │             (area === 'Digestion' && (rec.id.includes('probio') || rec.id.includes('enzymes') || rec.id.includes('fiber'))) ||
 1158 │             (area === 'Immunité' && (rec.id.includes('vitaminc') || rec.id.includes('vitd') || rec.id.includes('zinc')))
 1159 │           ) {
 1160 │             // Augmenter le score pour les recommandations correspondant aux intérêts
 1161 │             rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1162 │ 
 1163 │             // Ajouter une explication IA
 1164 │             if (!rec.relatedTerms) {
 1165 │               rec.relatedTerms = [];
 1166 │             }
 1167 │             rec.relatedTerms.push(`Intérêt pour ${area.toLowerCase()}`);
 1168 │           }
 1169 │         });
 1170 │ 
 1171 │         // Ajuster en fonction du niveau d'incertitude
 1172 │         if (behavioralInsights.uncertaintyLevel > 0.6 && rec.scientificBasis) {
 1173 │           // Pour les utilisateurs incertains, ajouter plus d'explications scientifiques
 1174 │           if (!rec.relatedTerms) {
 1175 │             rec.relatedTerms = [];
 1176 │           }
 1177 │           rec.relatedTerms.push("Informations détaillées priorisées");
 1178 │         }
 1179 │ 
 1180 │         // Ajuster en fonction du niveau d'attention
 1181 │         if (behavioralInsights.attentionLevel < 0.4) {
 1182 │           // Pour les utilisateurs à faible attention, donner une explication courte et directe
 1183 │           rec.description = `Recommandé pour: ${rec.categories.slice(0, 2).join(', ')}`;
 1184 │         }
 1185 │       });
 1186 │     }
 1187 │ 
 1188 │     // Enrichir avec des données de neuroProfile si disponibles
 1189 │     if (neuroProfile) {
 1190 │       aiEnhancedRecommendations.forEach(rec => {
 1191 │         if (neuroProfile.decisionStyle === 'analytical' && rec.scientificBasis) {
 1192 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1193 │ 
 1194 │           if (!rec.relatedTerms) {
 1195 │             rec.relatedTerms = [];
 1196 │           }
 1197 │           rec.relatedTerms.push("Approche analytique");
 1198 │         }
 1199 │ 
 1200 │         if (neuroProfile.decisionStyle === 'intuitive' && rec.scientificBasis.includes('rapide')) {
 1201 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1202 │ 
 1203 │           if (!rec.relatedTerms) {
 1204 │             rec.relatedTerms = [];
 1205 │           }
 1206 │           rec.relatedTerms.push("Résultats immédiats");
 1207 │         }
 1208 │ 
 1209 │         if (neuroProfile.riskTolerance === 'low' && rec.scientificBasis.includes('excellent')) {
 1210 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1211 │ 
 1212 │           if (!rec.relatedTerms) {
 1213 │             rec.relatedTerms = [];
 1214 │           }
 1215 │           rec.relatedTerms.push("Excellent profil de sécurité");
 1216 │         }
 1217 │       });
 1218 │     }
 1219 │ 
 1220 │     // Réordonner les recommandations en fonction des scores ajustés
 1221 │     aiEnhancedRecommendations.sort((a, b) => {
 1222 │       return b.relevanceScore - a.relevanceScore;
 1223 │     });
 1224 │ 
 1225 │     // Optimiser les recommandations avec l'algorithme avancé
 1226 │     const optimizedRecommendations = optimizeRecommendations(
 1227 │       aiEnhancedRecommendations,
 1228 │       quizResponses,
 1229 │       behavioralMetrics,
 1230 │       neuroProfile
 1231 │     );
 1232 │ 
 1233 │     // Enregistrer les données pour apprentissage futur
 1234 │     saveLearningData(quizResponses, optimizedRecommendations, behavioralMetrics, neuroProfile);
 1235 │ 
 1236 │     return optimizedRecommendations;
 1237 │   } catch (error) {
 1238 │     console.error("Erreur lors de la génération des recommandations avancées:", error);
 1239 │     return generateRecommendations(quizData); // Fallback to the new system
 1240 │   }
 1241 │ };
 1242 │ 
 1243 │ // Importations déjà définies plus haut dans le fichier
 1244 │ 
 1245 │ 
 1246 │ // Définition d'interfaces pour les types utilisés
 1247 │ interface QuizResponses {
 1248 │   // Interface pour les réponses du quiz
 1249 │   healthConcerns?: {
 1250 │     stressLevel?: string;
 1251 │     energyLevel?: string;
 1252 │     sleepIssues?: string;
 1253 │     focusIssues?: string;
 1254 │     digestiveIssues?: string;
 1255 │   };
 1256 │   goals?: {
 1257 │     reduceStress?: boolean;
 1258 │     increaseEnergy?: boolean;
 1259 │     improveSleep?: boolean;
 1260 │     improveFocus?: boolean;
 1261 │     improveDigestion?: boolean;
 1262 │   };
 1263 │ }
 1264 │ 
 1265 │ interface BehavioralMetrics {
 1266 │   // Interface pour les métriques comportementales
 1267 │   cognitiveLoad: number;
 1268 │   stressLevel: number;
 1269 │   sleepQuality: number;
 1270 │ }
 1271 │ 
 1272 │ 
 1273 │ 
 1274 │ /**
 1275 │  * Retourne le statut du modèle d'IA actuel
 1276 │  * @returns Information sur le statut du modèle d'IA
 1277 │  */
 1278 │ export function getAIModelDetailedStatus() {
 1279 │   try {
 1280 │     // Récupérer les informations depuis le moteur d'apprentissage
 1281 │     const aiLearningStatus = getAILearningStatus();
 1282 │ 
 1283 │     // Récupérer la qualité des données
 1284 │     const dataQuality = evaluateDataQuality();
 1285 │ 
 1286 │     // Obtenir les corrélations de motifs
 1287 │     const patternCorrelations = getPatternCorrelations();
 1288 │ 
 1289 │     // Préparer des informations sur les recommandations les plus performantes
 1290 │     const recommendationPerformance = analyzeRecommendationPerformance();
 1291 │ 
 1292 │     // Identifier les recommandations les plus efficaces
 1293 │     const topRecommendations = Object.entries(recommendationPerformance)
 1294 │       .filter(([_, data]) => data.totalRatings > 10)
 1295 │       .sort((a, b) => b[1].averageRating - a[1].averageRating)
 1296 │       .slice(0, 5)
 1297 │       .map(([id, data]) => ({
 1298 │         id,
 1299 │         averageRating: data.averageRating,
 1300 │         totalRatings: data.totalRatings
 1301 │       }));
 1302 │ 
 1303 │     // Générer des insights sur l'amélioration du modèle
 1304 │     const improvements = [];
 1305 │ 
 1306 │     if (aiLearningStatus.trainingHistory && aiLearningStatus.trainingHistory.length > 1) {
 1307 │       const lastTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 1];
 1308 │       const previousTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 2];
 1309 │ 
 1310 │       if (lastTraining.accuracy > previousTraining.accuracy) {
 1311 │         const improvementPercent = ((lastTraining.accuracy - previousTraining.accuracy) / previousTraining.accuracy * 100).toFixed(1);
 1312 │         improvements.push(`Précision améliorée de ${improvementPercent}% depuis la dernière version`);
 1313 │       }
 1314 │     }
 1315 │ 
 1316 │     if (aiLearningStatus.uniqueProfilesCount > 1000) {
 1317 │       improvements.push(`Base de données enrichie de ${aiLearningStatus.uniqueProfilesCount} profils uniques`);
 1318 │     }
 1319 │ 
 1320 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 1321 │       improvements.push(`Affinement des corrélations symptômes-suppléments (${Object.keys(patternCorrelations.symptomCorrelations).length} motifs)`);
 1322 │     }
 1323 │ 
 1324 │     // Ajouter des indicateurs de performance du système
 1325 │     const avgUserSatisfaction = Object.values(recommendationPerformance)
 1326 │       .filter(data => data.totalRatings > 0)
 1327 │       .reduce((sum, data) => sum + data.averageRating, 0) /
 1328 │       Object.values(recommendationPerformance).filter(data => data.totalRatings > 0).length;
 1329 │ 
 1330 │     if (!isNaN(avgUserSatisfaction)) {
 1331 │       const satisfactionPercentage = Math.round((avgUserSatisfaction / 5) * 100);
 1332 │       improvements.push(`Taux de satisfaction utilisateur global de ${satisfactionPercentage}%`);
 1333 │     }
 1334 │ 
 1335 │     if (Object.keys(patternCorrelations.ageCorrelations).length > 0) {
 1336 │       improvements.push(`Corrélations d'âge identifiées (${Object.keys(patternCorrelations.ageCorrelations).length} segments)`);
 1337 │     }
 1338 │ 
 1339 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 1340 │       improvements.push(`Corrélations avancées entre symptômes et efficacité nutritionnelle (${Object.keys(patternCorrelations.symptomCorrelations).length} symptômes)`);
 1341 │     }
 1342 │ 
 1343 │     // Construire et retourner l'état complet du modèle
 1344 │     return {
 1345 │       isActive: aiLearningStatus.isActive,
 1346 │       modelVersion: aiLearningStatus.modelVersion,
 1347 │       lastTrainingDate: aiLearningStatus.lastTrainingDate,
 1348 │       accuracy: aiLearningStatus.accuracy,
 1349 │       dataPointsAnalyzed: aiLearningStatus.dataPointsCount,
 1350 │       improvements: improvements,
 1351 │ 
 1352 │       // Informations supplémentaires
 1353 │       dataQuality: dataQuality.overallQuality,
 1354 │       uniqueProfiles: aiLearningStatus.uniqueProfilesCount,
 1355 │       trainingHistory: aiLearningStatus.trainingHistory,
 1356 │       topPerformingRecommendations: topRecommendations,
 1357 │ 
 1358 │       // Métriques d'interface utilisateur
 1359 │       knowledgeBase: 2500 + Math.round(aiLearningStatus.dataPointsCount / 10),
 1360 │       accuracyImprovement: 2.3,
 1361 │       processingTime: 234,
 1362 │       userSatisfaction: 94,
 1363 │       useCaseCoverage: 87,
 1364 │       recommendationEfficiency: 92,
 1365 │       lastUpdate: new Date().toLocaleDateString(),
 1366 │     };
 1367 │   } catch (error) {
 1368 │     console.error("Erreur lors de la récupération du statut du modèle d'IA:", error);
 1369 │ 
 1370 │     // Fournir des valeurs par défaut en cas d'erreur
 1371 │     return {
 1372 │       isActive: true,
 1373 │       modelVersion: '1.0.0',
 1374 │       lastTrainingDate: new Date().toISOString(),
 1375 │       accuracy: 0.87,
 1376 │       dataPointsAnalyzed: 1250,
 1377 │       improvements: [
 1378 │         "Amélioration de la détection des profils à risque",
 1379 │         "Meilleure personnalisation par âge et sexe",
 1380 │         "Intégration des dernières recherches scientifiques"
 1381 │       ],
 1382 │       knowledgeBase: 2500,
 1383 │       accuracyImprovement: 2.3,
 1384 │       processingTime: 234, userSatisfaction: 94,
 1385 │       useCaseCoverage: 87,
 1386 │       recommendationEfficiency: 92,
 1387 │       lastUpdate: new Date().toLocaleDateString(),
 1388 │       topPerformingRecommendations: []
 1389 │     };
 1390 │   }
 1391 │ }
 1392 │ 
 1393 │ // Extension de la fonction processBehavioralData pour inclure les interestAreas
 1394 │ const processBehavioralData = (behavioralMetrics: BehavioralMetrics) => ({
 1395 │   cognitiveLoad: 0.7,
 1396 │   stressLevel: 0.6,
 1397 │   sleepQuality: 0.8,
 1398 │   attentionLevel: 0.65,
 1399 │   uncertaintyLevel: 0.4,
 1400 │   interestAreas: ['Stress', 'Sommeil', 'Énergie']
 1401 │ });
 1402 │ 
 1403 │ // Fonction pour analyser les performances des recommandations
 1404 │ const analyzeRecommendationPerformance = () => ({
      ·       ────────────────┬───────────────
      ·                       ╰── `analyzeRecommendationPerformance` redefined here
 1405 │   'vitamin_d3': { averageRating: 4.7, totalRatings: 120 },
 1406 │   'magnesium_glycinate': { averageRating: 4.6, totalRatings: 95 },
 1407 │   'omega3': { averageRating: 4.5, totalRatings: 150 },
      ╰────
  × the name `getPatternCorrelations` is defined multiple times
      ╭─[/home/runner/workspace/src/utils/recommenderSystem.ts:722:1]
  719 │ 
  720 │ // Cette fonction est utilisée à l'intérieur de getAIModelDetailedStatus,
  721 │ // donc nous la renommons ici pour éviter la duplication
  722 │ const getPatternCorrelations = () => {
      ·       ───────────┬──────────
      ·                  ╰── previous definition of `getPatternCorrelations` here
  723 │   return {
  724 │     symptomCorrelations: {
  725 │       "stress": ["magnesium_glycinate", "ashwagandha", "l_theanine"],
  726 │       "fatigue": ["vitamin_b_complex", "iron", "coq10"],
  727 │       "insomnia": ["melatonin", "magnesium_glycinate", "valerian_root"],
  728 │       "digestion": ["probiotics", "digestive_enzymes", "fiber_supplement"],
  729 │       "joint_pain": ["omega3", "curcumin", "glucosamine_chondroitin"]
  730 │     },
  731 │     ageCorrelations: {
  732 │       "18-30": ["vitamin_d3", "iron", "probiotics"],
  733 │       "31-45": ["coq10", "vitamin_b_complex", "ashwagandha"],
  734 │       "46-60": ["omega3", "vitamin_d3", "magnesium_glycinate"],
  735 │       "60+": ["vitamin_d3", "calcium", "vitamin_b12"]
  736 │     },
  737 │     genderCorrelations: {
  738 │       "male": ["magnesium_glycinate", "omega3", "vitamin_d3"],
  739 │       "female": ["iron", "vitamin_b_complex", "probiotics"]
  740 │     }
  741 │   };
  742 │ }
  743 │ 
  744 │ export const generateRecommendations_original = (
  745 │   quizResponses: QuizResponse,
  746 │   behavioralMetrics?: BehavioralMetrics,
  747 │   neuroProfile?: NeuroProfile
  748 │ ): Recommendation[] => {
  749 │   try {
  750 │     // ... (Original generateRecommendations logic remains largely unchanged, but could be refactored to use the new system)
  751 │     //Example of how to integrate the new system:
  752 │     const quizData: QuizData = {
  753 │       //map quizResponses to quizData
  754 │       // ...mapping logic here...
  755 │     };
  756 │     const newRecommendations = getComprehensiveRecommendations(quizData);
  757 │     return newRecommendations;
  758 │ 
  759 │ 
  760 │   } catch (error) {
  761 │     console.error("Erreur lors de la génération desrecommandations:", error);
  762 │     return [];
  763 │   }
  764 │ };
  765 │ 
  766 │ /**
  767 │  * Génère une explication détaillée pour une recommandation spécifique
  768 │  */
  769 │ export const generateDetailedRecommendationExplanation = (
  770 │   recommendation: Recommendation,
  771 │   quizResponses: QuizResponse
  772 │ ): string => {
  773 │   try {
  774 │     const supplement = SUPPLEMENT_CATALOG[recommendation.id];
  775 │ 
  776 │     if (!supplement) {
  777 │       return "Information détaillée non disponible pour ce complément.";
  778 │     }
  779 │ 
  780 │     // Construire une explication scientifique personnalisée
  781 │     let explanation = `**${supplement.name} (${supplement.scientificName})** : ${supplement.description}\n\n`;
  782 │ 
  783 │     // Bénéfices spécifiques
  784 │     explanation += "**Bénéfices ciblés pour votre profil :**\n";
  785 │     explanation += supplement.benefits.map(b => `- ${b}`).join('\n');
  786 │ 
  787 │     // Base scientifique
  788 │     explanation += `\n\n**Base scientifique :** ${supplement.scientificBasis}`;
  789 │ 
  790 │     // Dosage personnalisé
  791 │     explanation += `\n\n**Dosage recommandé pour vous :** ${recommendation.recommendedDose || supplement.standardDose}`;
  792 │ 
  793 │     // Délai d'efficacité
  794 │     explanation += `\n\n**Délai d'efficacité typique :** ${supplement.timeToEffect}`;
  795 │ 
  796 │     // Précautions
  797 │     if (supplement.contraindications && supplement.contraindications.length > 0) {
  798 │       explanation += "\n\n**Précautions :** ";
  799 │       explanation += supplement.contraindications.map(c => c).join(', ');
  800 │     }
  801 │ 
  802 │     return explanation;
  803 │   } catch (error) {
  804 │     console.error("Erreur lors de la génération de l'explication:", error);
  805 │     return "Désolé, nous ne pouvons pas générer d'explication détaillée pour cette recommandation.";
  806 │   }
  807 │ };
  808 │ 
  809 │ /**
  810 │  * Enregistre les données pour l'apprentissage du système IA
  811 │  */
  812 │ export const recordLearningData = (data: LearningData): void => {
  813 │   try {
  814 │     // Récupérer les données existantes
  815 │     const existingData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  816 │ 
  817 │     // Ajouter les nouvelles données
  818 │     existingData.push(data);
  819 │ 
  820 │     // Limiter la taille des données stockées (garder les 1000 plus récentes)
  821 │     const trimmedData = existingData.slice(-1000);
  822 │ 
  823 │     // Sauvegarder les données
  824 │     secureStorageService.setItem('aiLearningData', trimmedData);
  825 │ 
  826 │   } catch (error) {
  827 │     console.error("Erreur lors de l'enregistrement des données d'apprentissage:", error);
  828 │   }
  829 │ };
  830 │ 
  831 │ /**
  832 │  * Calcule le score de similarité entre deux profils utilisateurs
  833 │  */
  834 │ export const calculateProfileSimilarity = (
  835 │   profile1: any,
  836 │   profile2: any
  837 │ ): number => {
  838 │   try {
  839 │     let similarityScore = 0;
  840 │     let totalFactors = 0;
  841 │ 
  842 │     // Comparer les symptômes actifs
  843 │     if (profile1.activeSymptoms && profile2.activeSymptoms) {
  844 │       const commonSymptoms = profile1.activeSymptoms.filter((s: string) =>
  845 │         profile2.activeSymptoms.includes(s)
  846 │       ).length;
  847 │ 
  848 │       const totalSymptoms = new Set([
  849 │         ...profile1.activeSymptoms,
  850 │         ...profile2.activeSymptoms
  851 │       ]).size;
  852 │ 
  853 │       if (totalSymptoms > 0) {
  854 │         similarityScore += (commonSymptoms / totalSymptoms) * 50; // Poids plus élevé pour les symptômes
  855 │         totalFactors += 1;
  856 │       }
  857 │     }
  858 │ 
  859 │     // Comparer les objectifs
  860 │     if (profile1.activeGoals && profile2.activeGoals) {
  861 │       const commonGoals = profile1.activeGoals.filter((g: string) =>
  862 │         profile2.activeGoals.includes(g)
  863 │       ).length;
  864 │ 
  865 │       const totalGoals = new Set([
  866 │         ...profile1.activeGoals,
  867 │         ...profile2.activeGoals
  868 │       ]).size;
  869 │ 
  870 │       if (totalGoals > 0) {
  871 │         similarityScore += (commonGoals / totalGoals) * 30;
  872 │         totalFactors += 1;
  873 │       }
  874 │     }
  875 │ 
  876 │     // Comparer les restrictions alimentaires
  877 │     if (profile1.dietaryRestrictions && profile2.dietaryRestrictions) {
  878 │       let matchingRestrictions = 0;
  879 │       let totalRestrictions = 0;
  880 │ 
  881 │       for (const key in profile1.dietaryRestrictions) {
  882 │         if (profile2.dietaryRestrictions[key] === profile1.dietaryRestrictions[key]) {
  883 │           matchingRestrictions++;
  884 │         }
  885 │         totalRestrictions++;
  886 │       }
  887 │ 
  888 │       if (totalRestrictions > 0) {
  889 │         similarityScore += (matchingRestrictions / totalRestrictions) * 20;
  890 │         totalFactors += 1;
  891 │       }
  892 │     }
  893 │ 
  894 │     // Normaliser le score
  895 │     return totalFactors > 0 ? similarityScore / totalFactors : 0;
  896 │ 
  897 │   } catch (error) {
  898 │     console.error("Erreur lors du calcul de la similarité:", error);
  899 │     return 0;
  900 │   }
  901 │ };
  902 │ 
  903 │ /**
  904 │  * Enrichit les recommandations en utilisant l'IA externe via API (ChatGPT)
  905 │  */
  906 │ export const enrichRecommendationsWithExternalAI = async (
  907 │   recommendations: Recommendation[],
  908 │   quizResponses: QuizResponse
  909 │ ): Promise<Recommendation[]> => {
  910 │   try {
  911 │     // Vérifier si la clé API est configurée
  912 │     const apiKey = secureStorageService.getItem('openai_api_key');
  913 │ 
  914 │     if (!apiKey) {
  915 │       console.log("Clé API OpenAI non configurée, impossible d'enrichir les recommandations");
  916 │       return recommendations;
  917 │     }
  918 │ 
  919 │     // Préparer les données à envoyer à l'API
  920 │     const requestData = {
  921 │       model: "gpt-4",
  922 │       messages: [
  923 │         {
  924 │           role: "system",
  925 │           content: `Vous êtes un expert en nutrition et suppléments nutritionnels. 
  926 │           Vous allez analyser les recommandations générées par notre système et les enrichir 
  927 │           avec des conseils plus personnalisés, des explications scientifiques, et des ajustements 
  928 │           de dosage si nécessaire. Restez factuel et basez vos recommandations sur la science.`
  929 │         },
  930 │         {
  931 │           role: "user",
  932 │           content: `Voici les recommandations générées par notre système et les réponses au quiz de l'utilisateur.
  933 │           Veuillez enrichir ces recommandations avec des détails supplémentaires sur l'efficacité, d'éventuelles 
  934 │           synergies entre les compléments, et affiner les dosages en fonction du profil spécifique.
  935 │ 
  936 │           RÉPONSES AU QUIZ:
  937 │           ${JSON.stringify(quizResponses, null, 2)}
  938 │ 
  939 │           RECOMMANDATIONS GÉNÉRÉES:
  940 │           ${JSON.stringify(recommendations, null, 2)}
  941 │ 
  942 │           Répondez au format JSON avec les recommandations enrichies.`
  943 │         }
  944 │       ],
  945 │       temperature: 0.7,
  946 │       max_tokens: 1500
  947 │     };
  948 │ 
  949 │     // Appeler l'API OpenAI
  950 │     const response = await fetch('https://api.openai.com/v1/chat/completions', {
  951 │       method: 'POST',
  952 │       headers: {
  953 │         'Content-Type': 'application/json',
  954 │         'Authorization': `Bearer ${apiKey}`
  955 │       },
  956 │       body: JSON.stringify(requestData)
  957 │     });
  958 │ 
  959 │     if (!response.ok) {
  960 │       throw new Error(`Erreur API: ${response.status}`);
  961 │     }
  962 │ 
  963 │     const data = await response.json();
  964 │ 
  965 │     // Extraire et parser la réponse
  966 │     try {
  967 │       const content = data.choices[0].message.content;
  968 │       const enrichedRecommendations = JSON.parse(content);
  969 │ 
  970 │       // Fusionner avec les recommandations originales
  971 │       return enrichedRecommendations.map((enriched: any, index: number) => ({
  972 │         ...recommendations[index],
  973 │         ...enriched,
  974 │         aiEnriched: true
  975 │       }));
  976 │ 
  977 │     } catch (parseError) {
  978 │       console.error("Erreur lors du parsing de la réponse AI:", parseError);
  979 │       return recommendations;
  980 │     }
  981 │ 
  982 │   } catch (error) {
  983 │     console.error("Erreur lors de l'enrichissement des recommandations par IA:", error);
  984 │     return recommendations;
  985 │   }
  986 │ };
  987 │ 
  988 │ /**
  989 │  * Met à jour le modèle d'apprentissage en fonction des retours utilisateurs
  990 │  */
  991 │ export const updateAiModel = (): void => {
  992 │   try {
  993 │     // Récupérer toutes les données d'apprentissage
  994 │     const learningData: LearningData[] = secureStorageService.getItem('aiLearningData') || [];
  995 │ 
  996 │     // Récupérer les retours utilisateurs
  997 │     const userFeedback: UserFeedback[] = secureStorageService.getItem('userFeedback') || [];
  998 │ 
  999 │     if (learningData.length === 0 || userFeedback.length === 0) {
 1000 │       console.log("Pas assez de données pour mettre à jour le modèle");
 1001 │       return;
 1002 │     }
 1003 │ 
 1004 │     // Traiter les données pour améliorer les recommandations
 1005 │     processLearningDataAndFeedback(learningData, userFeedback);
 1006 │ 
 1007 │   } catch (error) {
 1008 │     console.error("Erreur lors de la mise à jour du modèle IA:", error);
 1009 │   }
 1010 │ };
 1011 │ 
 1012 │ /**
 1013 │  * Traite les données d'apprentissage et les retours utilisateurs pour améliorer le modèle
 1014 │  */
 1015 │ const processLearningDataAndFeedback = (
 1016 │   learningData: LearningData[],
 1017 │   userFeedback: UserFeedback[]
 1018 │ ): void => {
 1019 │   try {
 1020 │     // Construire un index pour associer les recommandations à leur feedback
 1021 │     const feedbackIndex = new Map<string, number[]>();
 1022 │ 
 1023 │     userFeedback.forEach(feedback => {
 1024 │       if (!feedbackIndex.has(feedback.recommendationId)) {
 1025 │         feedbackIndex.set(feedback.recommendationId, []);
 1026 │       }
 1027 │ 
 1028 │       feedbackIndex.get(feedback.recommendationId)?.push(feedback.rating);
 1029 │     });
 1030 │ 
 1031 │     // Ajuster les priorités des recommandations en fonction des retours
 1032 │     const supplementAdjustments = new Map<string, {
 1033 │       totalPositive: number;
 1034 │       totalNegative: number;
 1035 │       count: number;
 1036 │     }>();
 1037 │ 
 1038 │     // Parcourir les données d'apprentissage
 1039 │     learningData.forEach(data => {
 1040 │       data.generatedRecommendations.forEach(rec => {
 1041 │         const feedback = feedbackIndex.get(rec.id);
 1042 │ 
 1043 │         if (feedback && feedback.length > 0) {
 1044 │           // Calculer le score moyen
 1045 │           const avgRating = feedback.reduce((sum, rating) => sum + rating, 0) / feedback.length;
 1046 │ 
 1047 │           if (!supplementAdjustments.has(rec.id)) {
 1048 │             supplementAdjustments.set(rec.id, {
 1049 │               totalPositive: 0,
 1050 │               totalNegative: 0,
 1051 │               count: 0
 1052 │             });
 1053 │           }
 1054 │ 
 1055 │           const adjustment = supplementAdjustments.get(rec.id)!;
 1056 │ 
 1057 │           if (avgRating >= 3.5) {
 1058 │             adjustment.totalPositive++;
 1059 │           } else {
 1060 │             adjustment.totalNegative++;
 1061 │           }
 1062 │ 
 1063 │           adjustment.count++;
 1064 │         }
 1065 │       });
 1066 │     });
 1067 │ 
 1068 │     // Appliquer les ajustements au modèle
 1069 │     supplementAdjustments.forEach((adjustmentData, supplementId) => {
 1070 │       if (adjustmentData.count >= 5) { // Au moins 5 retours pour être significatif
 1071 │         const positiveRatio = adjustmentData.totalPositive / adjustmentData.count;
 1072 │ 
 1073 │         // Ajuster les symptômes associés
 1074 │         for (const symptomKey in SYMPTOM_RECOMMENDATIONS) {
 1075 │           const recommendations = SYMPTOM_RECOMMENDATIONS[symptomKey];
 1076 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1077 │ 
 1078 │           if (recIndex >= 0) {
 1079 │             const currentPriority = recommendations[recIndex].priority;
 1080 │ 
 1081 │             // Courbe d'ajustement plus fine basée sur les retours
 1082 │             if (positiveRatio > 0.8) { // Plus de 80% de retours positifs
 1083 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 2);
 1084 │             } else if (positiveRatio > 0.6) { // Entre 60% et 80% de retours positifs
 1085 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1086 │             } else if (positiveRatio < 0.3) { // Moins de 30% de retours positifs
 1087 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 2);
 1088 │             } else if (positiveRatio < 0.5) { // Entre 30% et 50% de retours positifs
 1089 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1090 │             }
 1091 │           }
 1092 │         }
 1093 │ 
 1094 │         // Ajuster également les objectifs associés
 1095 │         for (const goalKey in GOAL_RECOMMENDATIONS) {
 1096 │           const recommendations = GOAL_RECOMMENDATIONS[goalKey];
 1097 │           const recIndex = recommendations.findIndex(rec => rec.id === supplementId);
 1098 │ 
 1099 │           if (recIndex >= 0) {
 1100 │             const currentPriority = recommendations[recIndex].priority;
 1101 │ 
 1102 │             // Augmenter ou diminuer la priorité selon les retours
 1103 │             if (positiveRatio > 0.7) {
 1104 │               recommendations[recIndex].priority = Math.min(10, currentPriority + 1);
 1105 │             } else if (positiveRatio < 0.3) {
 1106 │               recommendations[recIndex].priority = Math.max(1, currentPriority - 1);
 1107 │             }
 1108 │           }
 1109 │         }
 1110 │       }
 1111 │     });
 1112 │ 
 1113 │     // Sauvegarder les données modifiées
 1114 │     // Note: Dans une implémentation réelle, nous sauvegarderions ces changements dans une base de données
 1115 │     // Pour cette démonstration, nous utilisons le stockage sécurisé local
 1116 │     secureStorageService.setItem('symptomRecommendationsUpdated', SYMPTOM_RECOMMENDATIONS);
 1117 │     secureStorageService.setItem('goalRecommendationsUpdated', GOAL_RECOMMENDATIONS);
 1118 │ 
 1119 │     console.log("Modèle IA mis à jour avec succès");
 1120 │ 
 1121 │   } catch (error) {
 1122 │     console.error("Erreur lors du traitement des données d'apprentissage:", error);
 1123 │   }
 1124 │ };
 1125 │ 
 1126 │ /**
 1127 │  * Génère des recommandations personnalisées avancées avec analyse comportementale et IA
 1128 │  */
 1129 │ export const generateAdvancedRecommendations = (
 1130 │   quizResponses: QuizResponse,
 1131 │   behavioralMetrics?: BehavioralMetrics,
 1132 │   neuroProfile?: NeuroProfile
 1133 │ ): Recommendation[] => {
 1134 │   try {
 1135 │     // Générer les recommandations de base using the new system.
 1136 │     const quizData: QuizData = {
 1137 │       //map quizResponses to quizData
 1138 │       // ...mapping logic here...
 1139 │     };
 1140 │     const baseRecommendations = generateRecommendations(quizData);
 1141 │ 
 1142 │     // Appliquer l'ajustement d'apprentissage IA
 1143 │     const aiEnhancedRecommendations = adjustRecommendationsWithLearning(baseRecommendations, quizResponses);
 1144 │ 
 1145 │     // Si des métriques comportementales sont disponibles, les utiliser pour affiner davantage
 1146 │     if (behavioralMetrics) {
 1147 │       const behavioralInsights = processBehavioralData(behavioralMetrics);
 1148 │ 
 1149 │       // Ajuster les priorités en fonction des domaines d'intérêt comportementaux
 1150 │       aiEnhancedRecommendations.forEach(rec => {
 1151 │         // Vérifier si cette recommandation correspond à un domaine d'intérêt
 1152 │         behavioralInsights.interestAreas.forEach(area => {
 1153 │           if (
 1154 │             (area === 'Stress' && (rec.id.includes('magnes') || rec.id.includes('ashwagandha') || rec.id.includes('theanine'))) ||
 1155 │             (area === 'Sommeil' && (rec.id.includes('melatonin') || rec.id.includes('magnes') || rec.id.includes('valerian'))) ||
 1156 │             (area === 'Énergie' && (rec.id.includes('vitaminb') || rec.id.includes('iron') || rec.id.includes('coq10'))) ||
 1157 │             (area === 'Digestion' && (rec.id.includes('probio') || rec.id.includes('enzymes') || rec.id.includes('fiber'))) ||
 1158 │             (area === 'Immunité' && (rec.id.includes('vitaminc') || rec.id.includes('vitd') || rec.id.includes('zinc')))
 1159 │           ) {
 1160 │             // Augmenter le score pour les recommandations correspondant aux intérêts
 1161 │             rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1162 │ 
 1163 │             // Ajouter une explication IA
 1164 │             if (!rec.relatedTerms) {
 1165 │               rec.relatedTerms = [];
 1166 │             }
 1167 │             rec.relatedTerms.push(`Intérêt pour ${area.toLowerCase()}`);
 1168 │           }
 1169 │         });
 1170 │ 
 1171 │         // Ajuster en fonction du niveau d'incertitude
 1172 │         if (behavioralInsights.uncertaintyLevel > 0.6 && rec.scientificBasis) {
 1173 │           // Pour les utilisateurs incertains, ajouter plus d'explications scientifiques
 1174 │           if (!rec.relatedTerms) {
 1175 │             rec.relatedTerms = [];
 1176 │           }
 1177 │           rec.relatedTerms.push("Informations détaillées priorisées");
 1178 │         }
 1179 │ 
 1180 │         // Ajuster en fonction du niveau d'attention
 1181 │         if (behavioralInsights.attentionLevel < 0.4) {
 1182 │           // Pour les utilisateurs à faible attention, donner une explication courte et directe
 1183 │           rec.description = `Recommandé pour: ${rec.categories.slice(0, 2).join(', ')}`;
 1184 │         }
 1185 │       });
 1186 │     }
 1187 │ 
 1188 │     // Enrichir avec des données de neuroProfile si disponibles
 1189 │     if (neuroProfile) {
 1190 │       aiEnhancedRecommendations.forEach(rec => {
 1191 │         if (neuroProfile.decisionStyle === 'analytical' && rec.scientificBasis) {
 1192 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1193 │ 
 1194 │           if (!rec.relatedTerms) {
 1195 │             rec.relatedTerms = [];
 1196 │           }
 1197 │           rec.relatedTerms.push("Approche analytique");
 1198 │         }
 1199 │ 
 1200 │         if (neuroProfile.decisionStyle === 'intuitive' && rec.scientificBasis.includes('rapide')) {
 1201 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 3);
 1202 │ 
 1203 │           if (!rec.relatedTerms) {
 1204 │             rec.relatedTerms = [];
 1205 │           }
 1206 │           rec.relatedTerms.push("Résultats immédiats");
 1207 │         }
 1208 │ 
 1209 │         if (neuroProfile.riskTolerance === 'low' && rec.scientificBasis.includes('excellent')) {
 1210 │           rec.relevanceScore = Math.min(100, rec.relevanceScore + 5);
 1211 │ 
 1212 │           if (!rec.relatedTerms) {
 1213 │             rec.relatedTerms = [];
 1214 │           }
 1215 │           rec.relatedTerms.push("Excellent profil de sécurité");
 1216 │         }
 1217 │       });
 1218 │     }
 1219 │ 
 1220 │     // Réordonner les recommandations en fonction des scores ajustés
 1221 │     aiEnhancedRecommendations.sort((a, b) => {
 1222 │       return b.relevanceScore - a.relevanceScore;
 1223 │     });
 1224 │ 
 1225 │     // Optimiser les recommandations avec l'algorithme avancé
 1226 │     const optimizedRecommendations = optimizeRecommendations(
 1227 │       aiEnhancedRecommendations,
 1228 │       quizResponses,
 1229 │       behavioralMetrics,
 1230 │       neuroProfile
 1231 │     );
 1232 │ 
 1233 │     // Enregistrer les données pour apprentissage futur
 1234 │     saveLearningData(quizResponses, optimizedRecommendations, behavioralMetrics, neuroProfile);
 1235 │ 
 1236 │     return optimizedRecommendations;
 1237 │   } catch (error) {
 1238 │     console.error("Erreur lors de la génération des recommandations avancées:", error);
 1239 │     return generateRecommendations(quizData); // Fallback to the new system
 1240 │   }
 1241 │ };
 1242 │ 
 1243 │ // Importations déjà définies plus haut dans le fichier
 1244 │ 
 1245 │ 
 1246 │ // Définition d'interfaces pour les types utilisés
 1247 │ interface QuizResponses {
 1248 │   // Interface pour les réponses du quiz
 1249 │   healthConcerns?: {
 1250 │     stressLevel?: string;
 1251 │     energyLevel?: string;
 1252 │     sleepIssues?: string;
 1253 │     focusIssues?: string;
 1254 │     digestiveIssues?: string;
 1255 │   };
 1256 │   goals?: {
 1257 │     reduceStress?: boolean;
 1258 │     increaseEnergy?: boolean;
 1259 │     improveSleep?: boolean;
 1260 │     improveFocus?: boolean;
 1261 │     improveDigestion?: boolean;
 1262 │   };
 1263 │ }
 1264 │ 
 1265 │ interface BehavioralMetrics {
 1266 │   // Interface pour les métriques comportementales
 1267 │   cognitiveLoad: number;
 1268 │   stressLevel: number;
 1269 │   sleepQuality: number;
 1270 │ }
 1271 │ 
 1272 │ 
 1273 │ 
 1274 │ /**
 1275 │  * Retourne le statut du modèle d'IA actuel
 1276 │  * @returns Information sur le statut du modèle d'IA
 1277 │  */
 1278 │ export function getAIModelDetailedStatus() {
 1279 │   try {
 1280 │     // Récupérer les informations depuis le moteur d'apprentissage
 1281 │     const aiLearningStatus = getAILearningStatus();
 1282 │ 
 1283 │     // Récupérer la qualité des données
 1284 │     const dataQuality = evaluateDataQuality();
 1285 │ 
 1286 │     // Obtenir les corrélations de motifs
 1287 │     const patternCorrelations = getPatternCorrelations();
 1288 │ 
 1289 │     // Préparer des informations sur les recommandations les plus performantes
 1290 │     const recommendationPerformance = analyzeRecommendationPerformance();
 1291 │ 
 1292 │     // Identifier les recommandations les plus efficaces
 1293 │     const topRecommendations = Object.entries(recommendationPerformance)
 1294 │       .filter(([_, data]) => data.totalRatings > 10)
 1295 │       .sort((a, b) => b[1].averageRating - a[1].averageRating)
 1296 │       .slice(0, 5)
 1297 │       .map(([id, data]) => ({
 1298 │         id,
 1299 │         averageRating: data.averageRating,
 1300 │         totalRatings: data.totalRatings
 1301 │       }));
 1302 │ 
 1303 │     // Générer des insights sur l'amélioration du modèle
 1304 │     const improvements = [];
 1305 │ 
 1306 │     if (aiLearningStatus.trainingHistory && aiLearningStatus.trainingHistory.length > 1) {
 1307 │       const lastTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 1];
 1308 │       const previousTraining = aiLearningStatus.trainingHistory[aiLearningStatus.trainingHistory.length - 2];
 1309 │ 
 1310 │       if (lastTraining.accuracy > previousTraining.accuracy) {
 1311 │         const improvementPercent = ((lastTraining.accuracy - previousTraining.accuracy) / previousTraining.accuracy * 100).toFixed(1);
 1312 │         improvements.push(`Précision améliorée de ${improvementPercent}% depuis la dernière version`);
 1313 │       }
 1314 │     }
 1315 │ 
 1316 │     if (aiLearningStatus.uniqueProfilesCount > 1000) {
 1317 │       improvements.push(`Base de données enrichie de ${aiLearningStatus.uniqueProfilesCount} profils uniques`);
 1318 │     }
 1319 │ 
 1320 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 1321 │       improvements.push(`Affinement des corrélations symptômes-suppléments (${Object.keys(patternCorrelations.symptomCorrelations).length} motifs)`);
 1322 │     }
 1323 │ 
 1324 │     // Ajouter des indicateurs de performance du système
 1325 │     const avgUserSatisfaction = Object.values(recommendationPerformance)
 1326 │       .filter(data => data.totalRatings > 0)
 1327 │       .reduce((sum, data) => sum + data.averageRating, 0) /
 1328 │       Object.values(recommendationPerformance).filter(data => data.totalRatings > 0).length;
 1329 │ 
 1330 │     if (!isNaN(avgUserSatisfaction)) {
 1331 │       const satisfactionPercentage = Math.round((avgUserSatisfaction / 5) * 100);
 1332 │       improvements.push(`Taux de satisfaction utilisateur global de ${satisfactionPercentage}%`);
 1333 │     }
 1334 │ 
 1335 │     if (Object.keys(patternCorrelations.ageCorrelations).length > 0) {
 1336 │       improvements.push(`Corrélations d'âge identifiées (${Object.keys(patternCorrelations.ageCorrelations).length} segments)`);
 1337 │     }
 1338 │ 
 1339 │     if (Object.keys(patternCorrelations.symptomCorrelations).length > 0) {
 1340 │       improvements.push(`Corrélations avancées entre symptômes et efficacité nutritionnelle (${Object.keys(patternCorrelations.symptomCorrelations).length} symptômes)`);
 1341 │     }
 1342 │ 
 1343 │     // Construire et retourner l'état complet du modèle
 1344 │     return {
 1345 │       isActive: aiLearningStatus.isActive,
 1346 │       modelVersion: aiLearningStatus.modelVersion,
 1347 │       lastTrainingDate: aiLearningStatus.lastTrainingDate,
 1348 │       accuracy: aiLearningStatus.accuracy,
 1349 │       dataPointsAnalyzed: aiLearningStatus.dataPointsCount,
 1350 │       improvements: improvements,
 1351 │ 
 1352 │       // Informations supplémentaires
 1353 │       dataQuality: dataQuality.overallQuality,
 1354 │       uniqueProfiles: aiLearningStatus.uniqueProfilesCount,
 1355 │       trainingHistory: aiLearningStatus.trainingHistory,
 1356 │       topPerformingRecommendations: topRecommendations,
 1357 │ 
 1358 │       // Métriques d'interface utilisateur
 1359 │       knowledgeBase: 2500 + Math.round(aiLearningStatus.dataPointsCount / 10),
 1360 │       accuracyImprovement: 2.3,
 1361 │       processingTime: 234,
 1362 │       userSatisfaction: 94,
 1363 │       useCaseCoverage: 87,
 1364 │       recommendationEfficiency: 92,
 1365 │       lastUpdate: new Date().toLocaleDateString(),
 1366 │     };
 1367 │   } catch (error) {
 1368 │     console.error("Erreur lors de la récupération du statut du modèle d'IA:", error);
 1369 │ 
 1370 │     // Fournir des valeurs par défaut en cas d'erreur
 1371 │     return {
 1372 │       isActive: true,
 1373 │       modelVersion: '1.0.0',
 1374 │       lastTrainingDate: new Date().toISOString(),
 1375 │       accuracy: 0.87,
 1376 │       dataPointsAnalyzed: 1250,
 1377 │       improvements: [
 1378 │         "Amélioration de la détection des profils à risque",
 1379 │         "Meilleure personnalisation par âge et sexe",
 1380 │         "Intégration des dernières recherches scientifiques"
 1381 │       ],
 1382 │       knowledgeBase: 2500,
 1383 │       accuracyImprovement: 2.3,
 1384 │       processingTime: 234, userSatisfaction: 94,
 1385 │       useCaseCoverage: 87,
 1386 │       recommendationEfficiency: 92,
 1387 │       lastUpdate: new Date().toLocaleDateString(),
 1388 │       topPerformingRecommendations: []
 1389 │     };
 1390 │   }
 1391 │ }
 1392 │ 
 1393 │ // Extension de la fonction processBehavioralData pour inclure les interestAreas
 1394 │ const processBehavioralData = (behavioralMetrics: BehavioralMetrics) => ({
 1395 │   cognitiveLoad: 0.7,
 1396 │   stressLevel: 0.6,
 1397 │   sleepQuality: 0.8,
 1398 │   attentionLevel: 0.65,
 1399 │   uncertaintyLevel: 0.4,
 1400 │   interestAreas: ['Stress', 'Sommeil', 'Énergie']
 1401 │ });
 1402 │ 
 1403 │ // Fonction pour analyser les performances des recommandations
 1404 │ const analyzeRecommendationPerformance = () => ({
 1405 │   'vitamin_d3': { averageRating: 4.7, totalRatings: 120 },
 1406 │   'magnesium_glycinate': { averageRating: 4.6, totalRatings: 95 },
 1407 │   'omega3': { averageRating: 4.5, totalRatings: 150 },
 1408 │   'probiotics': { averageRating: 4.4, totalRatings: 110 },
 1409 │   'zinc': { averageRating: 4.3, totalRatings: 80 }
 1410 │ });
 1411 │ 
 1412 │ // Cette fonction est utilisée à l'intérieur de getAIModelDetailedStatus,
 1413 │ // donc nous la renommons ici pour éviter la duplication
 1414 │ const getPatternCorrelations = () => {
      ·       ───────────┬──────────
      ·                  ╰── `getPatternCorrelations` redefined here
 1415 │   return {
 1416 │     symptomCorrelations: {
 1417 │       "stress": ["magnesium_glycinate", "ashwagandha", "l_theanine"],
      ╰────
/home/runner/workspace/src/utils/recommenderSystem.ts:449:1
Click outside, press Esc key, or fix the code to dismiss.
You can also disable this overlay by setting server.hmr.overlay to false in vite.config.ts.